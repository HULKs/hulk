use std::fmt::{self, Formatter};

use serde::{
    de::{self, Visitor},
    Deserialize, Deserializer,
};
use serde_bytes::ByteBuf;

pub struct CompressedImage {
    pub width_422: u32,
    pub height: u32,
    pub buffer: Vec<u8>,
}

impl<'de> Deserialize<'de> for CompressedImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        enum Field {
            Width422,
            Height,
            CompactBuffer,
            ReadableBuffer,
        }
        const FIELDS: &[&str] = &["width_422", "height", "buffer"];

        impl<'de> Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                struct FieldVisitor {
                    is_human_readable: bool,
                }

                impl<'de> Visitor<'de> for FieldVisitor {
                    type Value = Field;

                    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
                        formatter.write_str("`width_422`, `height`, or `buffer`")
                    }

                    fn visit_str<E>(self, field: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: de::Error,
                    {
                        match field {
                            "width_422" => Ok(Field::Width422),
                            "height" => Ok(Field::Height),
                            "buffer" => Ok(if self.is_human_readable {
                                Field::ReadableBuffer
                            } else {
                                Field::CompactBuffer
                            }),
                            _ => Err(de::Error::unknown_field(field, FIELDS)),
                        }
                    }
                }

                let is_human_readable = deserializer.is_human_readable();
                deserializer.deserialize_identifier(FieldVisitor { is_human_readable })
            }
        }

        struct ImageVisitor;

        impl<'de> Visitor<'de> for ImageVisitor {
            type Value = CompressedImage;

            fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
                // This says "Image", not "CompressedImage" because it is expected to deserialize from data
                // generated by the `Image` type.
                formatter.write_str("struct Image")
            }

            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
            where
                A: de::MapAccess<'de>,
            {
                let mut width_422 = None;
                let mut height = None;
                let mut buffer = None;

                while let Some(key) = map.next_key()? {
                    match key {
                        Field::Width422 => {
                            if width_422.is_some() {
                                return Err(de::Error::duplicate_field("width_422"));
                            }
                            width_422 = Some(map.next_value()?);
                        }
                        Field::Height => {
                            if height.is_some() {
                                return Err(de::Error::duplicate_field("height"));
                            }
                            height = Some(map.next_value()?);
                        }
                        Field::CompactBuffer => {
                            if buffer.is_some() {
                                return Err(de::Error::duplicate_field("buffer"));
                            }
                            let rgb_image_buffer: ByteBuf = map.next_value()?;
                            buffer = Some(rgb_image_buffer.to_vec());
                        }
                        Field::ReadableBuffer => {
                            if buffer.is_some() {
                                return Err(de::Error::duplicate_field("buffer"));
                            }
                            buffer = Some(map.next_value()?);
                        }
                    }
                }

                let width_422 = width_422.ok_or_else(|| de::Error::missing_field("width_422"))?;
                let height = height.ok_or_else(|| de::Error::missing_field("height"))?;
                let buffer = buffer.ok_or_else(|| de::Error::missing_field("buffer"))?;

                Ok(CompressedImage {
                    width_422,
                    height,
                    buffer,
                })
            }

            fn visit_seq<A>(self, mut seq: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: de::SeqAccess<'de>,
            {
                let width_422 = seq
                    .next_element::<u32>()?
                    .ok_or_else(|| de::Error::missing_field("width_422"))?;
                let height = seq
                    .next_element::<u32>()?
                    .ok_or_else(|| de::Error::missing_field("height"))?;
                let buffer = seq
                    .next_element::<ByteBuf>()?
                    .ok_or_else(|| de::Error::missing_field("buffer"))?
                    .to_vec();

                Ok(CompressedImage {
                    width_422,
                    height,
                    buffer,
                })
            }
        }

        // This says "Image", not "CompressedImage" because it is expected to deserialize from data
        // generated by the `Image` type.
        deserializer.deserialize_struct("Image", FIELDS, ImageVisitor)
    }
}

#[cfg(test)]
mod tests {
    use bincode::{deserialize, serialize};
    use types::{image::Image, YCbCr422};

    use super::*;

    #[test]
    fn raw_image_can_deserialize_image_data() {
        let image = Image::from_ycbcr_buffer(
            1,
            1,
            vec![YCbCr422 {
                y1: 0,
                cb: 1,
                y2: 2,
                cr: 3,
            }],
        );

        let data = serialize(&image).unwrap();
        let _new_image: CompressedImage = deserialize(&data).unwrap();
    }
}
