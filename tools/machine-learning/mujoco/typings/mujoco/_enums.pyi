from __future__ import annotations
import typing
__all__ = ['mjtAlignFree', 'mjtBias', 'mjtBuiltin', 'mjtButton', 'mjtCamLight', 'mjtCamera', 'mjtCatBit', 'mjtCone', 'mjtConstraint', 'mjtConstraintState', 'mjtDataType', 'mjtDepthMap', 'mjtDisableBit', 'mjtDyn', 'mjtEnableBit', 'mjtEq', 'mjtEvent', 'mjtFlexSelf', 'mjtFont', 'mjtFontScale', 'mjtFrame', 'mjtFramebuffer', 'mjtGain', 'mjtGeom', 'mjtGeomInertia', 'mjtGridPos', 'mjtInertiaFromGeom', 'mjtIntegrator', 'mjtItem', 'mjtJacobian', 'mjtJoint', 'mjtLRMode', 'mjtLabel', 'mjtLimited', 'mjtMark', 'mjtMeshInertia', 'mjtMouse', 'mjtObj', 'mjtOrientation', 'mjtPertBit', 'mjtPluginCapabilityBit', 'mjtRndFlag', 'mjtSameFrame', 'mjtSection', 'mjtSensor', 'mjtSolver', 'mjtStage', 'mjtState', 'mjtStereo', 'mjtTaskStatus', 'mjtTexture', 'mjtTextureRole', 'mjtTimer', 'mjtTrn', 'mjtVisFlag', 'mjtWarning', 'mjtWrap']
class mjtAlignFree:
    """
    Members:
    
      mjALIGNFREE_FALSE
    
      mjALIGNFREE_TRUE
    
      mjALIGNFREE_AUTO
    """
    __members__: typing.ClassVar[dict[str, mjtAlignFree]]  # value = {'mjALIGNFREE_FALSE': <mjtAlignFree.mjALIGNFREE_FALSE: 0>, 'mjALIGNFREE_TRUE': <mjtAlignFree.mjALIGNFREE_TRUE: 1>, 'mjALIGNFREE_AUTO': <mjtAlignFree.mjALIGNFREE_AUTO: 2>}
    mjALIGNFREE_AUTO: typing.ClassVar[mjtAlignFree]  # value = <mjtAlignFree.mjALIGNFREE_AUTO: 2>
    mjALIGNFREE_FALSE: typing.ClassVar[mjtAlignFree]  # value = <mjtAlignFree.mjALIGNFREE_FALSE: 0>
    mjALIGNFREE_TRUE: typing.ClassVar[mjtAlignFree]  # value = <mjtAlignFree.mjALIGNFREE_TRUE: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtBias:
    """
    Members:
    
      mjBIAS_NONE
    
      mjBIAS_AFFINE
    
      mjBIAS_MUSCLE
    
      mjBIAS_USER
    """
    __members__: typing.ClassVar[dict[str, mjtBias]]  # value = {'mjBIAS_NONE': <mjtBias.mjBIAS_NONE: 0>, 'mjBIAS_AFFINE': <mjtBias.mjBIAS_AFFINE: 1>, 'mjBIAS_MUSCLE': <mjtBias.mjBIAS_MUSCLE: 2>, 'mjBIAS_USER': <mjtBias.mjBIAS_USER: 3>}
    mjBIAS_AFFINE: typing.ClassVar[mjtBias]  # value = <mjtBias.mjBIAS_AFFINE: 1>
    mjBIAS_MUSCLE: typing.ClassVar[mjtBias]  # value = <mjtBias.mjBIAS_MUSCLE: 2>
    mjBIAS_NONE: typing.ClassVar[mjtBias]  # value = <mjtBias.mjBIAS_NONE: 0>
    mjBIAS_USER: typing.ClassVar[mjtBias]  # value = <mjtBias.mjBIAS_USER: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtBuiltin:
    """
    Members:
    
      mjBUILTIN_NONE
    
      mjBUILTIN_GRADIENT
    
      mjBUILTIN_CHECKER
    
      mjBUILTIN_FLAT
    """
    __members__: typing.ClassVar[dict[str, mjtBuiltin]]  # value = {'mjBUILTIN_NONE': <mjtBuiltin.mjBUILTIN_NONE: 0>, 'mjBUILTIN_GRADIENT': <mjtBuiltin.mjBUILTIN_GRADIENT: 1>, 'mjBUILTIN_CHECKER': <mjtBuiltin.mjBUILTIN_CHECKER: 2>, 'mjBUILTIN_FLAT': <mjtBuiltin.mjBUILTIN_FLAT: 3>}
    mjBUILTIN_CHECKER: typing.ClassVar[mjtBuiltin]  # value = <mjtBuiltin.mjBUILTIN_CHECKER: 2>
    mjBUILTIN_FLAT: typing.ClassVar[mjtBuiltin]  # value = <mjtBuiltin.mjBUILTIN_FLAT: 3>
    mjBUILTIN_GRADIENT: typing.ClassVar[mjtBuiltin]  # value = <mjtBuiltin.mjBUILTIN_GRADIENT: 1>
    mjBUILTIN_NONE: typing.ClassVar[mjtBuiltin]  # value = <mjtBuiltin.mjBUILTIN_NONE: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtButton:
    """
    Members:
    
      mjBUTTON_NONE
    
      mjBUTTON_LEFT
    
      mjBUTTON_RIGHT
    
      mjBUTTON_MIDDLE
    """
    __members__: typing.ClassVar[dict[str, mjtButton]]  # value = {'mjBUTTON_NONE': <mjtButton.mjBUTTON_NONE: 0>, 'mjBUTTON_LEFT': <mjtButton.mjBUTTON_LEFT: 1>, 'mjBUTTON_RIGHT': <mjtButton.mjBUTTON_RIGHT: 2>, 'mjBUTTON_MIDDLE': <mjtButton.mjBUTTON_MIDDLE: 3>}
    mjBUTTON_LEFT: typing.ClassVar[mjtButton]  # value = <mjtButton.mjBUTTON_LEFT: 1>
    mjBUTTON_MIDDLE: typing.ClassVar[mjtButton]  # value = <mjtButton.mjBUTTON_MIDDLE: 3>
    mjBUTTON_NONE: typing.ClassVar[mjtButton]  # value = <mjtButton.mjBUTTON_NONE: 0>
    mjBUTTON_RIGHT: typing.ClassVar[mjtButton]  # value = <mjtButton.mjBUTTON_RIGHT: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtCamLight:
    """
    Members:
    
      mjCAMLIGHT_FIXED
    
      mjCAMLIGHT_TRACK
    
      mjCAMLIGHT_TRACKCOM
    
      mjCAMLIGHT_TARGETBODY
    
      mjCAMLIGHT_TARGETBODYCOM
    """
    __members__: typing.ClassVar[dict[str, mjtCamLight]]  # value = {'mjCAMLIGHT_FIXED': <mjtCamLight.mjCAMLIGHT_FIXED: 0>, 'mjCAMLIGHT_TRACK': <mjtCamLight.mjCAMLIGHT_TRACK: 1>, 'mjCAMLIGHT_TRACKCOM': <mjtCamLight.mjCAMLIGHT_TRACKCOM: 2>, 'mjCAMLIGHT_TARGETBODY': <mjtCamLight.mjCAMLIGHT_TARGETBODY: 3>, 'mjCAMLIGHT_TARGETBODYCOM': <mjtCamLight.mjCAMLIGHT_TARGETBODYCOM: 4>}
    mjCAMLIGHT_FIXED: typing.ClassVar[mjtCamLight]  # value = <mjtCamLight.mjCAMLIGHT_FIXED: 0>
    mjCAMLIGHT_TARGETBODY: typing.ClassVar[mjtCamLight]  # value = <mjtCamLight.mjCAMLIGHT_TARGETBODY: 3>
    mjCAMLIGHT_TARGETBODYCOM: typing.ClassVar[mjtCamLight]  # value = <mjtCamLight.mjCAMLIGHT_TARGETBODYCOM: 4>
    mjCAMLIGHT_TRACK: typing.ClassVar[mjtCamLight]  # value = <mjtCamLight.mjCAMLIGHT_TRACK: 1>
    mjCAMLIGHT_TRACKCOM: typing.ClassVar[mjtCamLight]  # value = <mjtCamLight.mjCAMLIGHT_TRACKCOM: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtCamera:
    """
    Members:
    
      mjCAMERA_FREE
    
      mjCAMERA_TRACKING
    
      mjCAMERA_FIXED
    
      mjCAMERA_USER
    """
    __members__: typing.ClassVar[dict[str, mjtCamera]]  # value = {'mjCAMERA_FREE': <mjtCamera.mjCAMERA_FREE: 0>, 'mjCAMERA_TRACKING': <mjtCamera.mjCAMERA_TRACKING: 1>, 'mjCAMERA_FIXED': <mjtCamera.mjCAMERA_FIXED: 2>, 'mjCAMERA_USER': <mjtCamera.mjCAMERA_USER: 3>}
    mjCAMERA_FIXED: typing.ClassVar[mjtCamera]  # value = <mjtCamera.mjCAMERA_FIXED: 2>
    mjCAMERA_FREE: typing.ClassVar[mjtCamera]  # value = <mjtCamera.mjCAMERA_FREE: 0>
    mjCAMERA_TRACKING: typing.ClassVar[mjtCamera]  # value = <mjtCamera.mjCAMERA_TRACKING: 1>
    mjCAMERA_USER: typing.ClassVar[mjtCamera]  # value = <mjtCamera.mjCAMERA_USER: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtCatBit:
    """
    Members:
    
      mjCAT_STATIC
    
      mjCAT_DYNAMIC
    
      mjCAT_DECOR
    
      mjCAT_ALL
    """
    __members__: typing.ClassVar[dict[str, mjtCatBit]]  # value = {'mjCAT_STATIC': <mjtCatBit.mjCAT_STATIC: 1>, 'mjCAT_DYNAMIC': <mjtCatBit.mjCAT_DYNAMIC: 2>, 'mjCAT_DECOR': <mjtCatBit.mjCAT_DECOR: 4>, 'mjCAT_ALL': <mjtCatBit.mjCAT_ALL: 7>}
    mjCAT_ALL: typing.ClassVar[mjtCatBit]  # value = <mjtCatBit.mjCAT_ALL: 7>
    mjCAT_DECOR: typing.ClassVar[mjtCatBit]  # value = <mjtCatBit.mjCAT_DECOR: 4>
    mjCAT_DYNAMIC: typing.ClassVar[mjtCatBit]  # value = <mjtCatBit.mjCAT_DYNAMIC: 2>
    mjCAT_STATIC: typing.ClassVar[mjtCatBit]  # value = <mjtCatBit.mjCAT_STATIC: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtCone:
    """
    Members:
    
      mjCONE_PYRAMIDAL
    
      mjCONE_ELLIPTIC
    """
    __members__: typing.ClassVar[dict[str, mjtCone]]  # value = {'mjCONE_PYRAMIDAL': <mjtCone.mjCONE_PYRAMIDAL: 0>, 'mjCONE_ELLIPTIC': <mjtCone.mjCONE_ELLIPTIC: 1>}
    mjCONE_ELLIPTIC: typing.ClassVar[mjtCone]  # value = <mjtCone.mjCONE_ELLIPTIC: 1>
    mjCONE_PYRAMIDAL: typing.ClassVar[mjtCone]  # value = <mjtCone.mjCONE_PYRAMIDAL: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtConstraint:
    """
    Members:
    
      mjCNSTR_EQUALITY
    
      mjCNSTR_FRICTION_DOF
    
      mjCNSTR_FRICTION_TENDON
    
      mjCNSTR_LIMIT_JOINT
    
      mjCNSTR_LIMIT_TENDON
    
      mjCNSTR_CONTACT_FRICTIONLESS
    
      mjCNSTR_CONTACT_PYRAMIDAL
    
      mjCNSTR_CONTACT_ELLIPTIC
    """
    __members__: typing.ClassVar[dict[str, mjtConstraint]]  # value = {'mjCNSTR_EQUALITY': <mjtConstraint.mjCNSTR_EQUALITY: 0>, 'mjCNSTR_FRICTION_DOF': <mjtConstraint.mjCNSTR_FRICTION_DOF: 1>, 'mjCNSTR_FRICTION_TENDON': <mjtConstraint.mjCNSTR_FRICTION_TENDON: 2>, 'mjCNSTR_LIMIT_JOINT': <mjtConstraint.mjCNSTR_LIMIT_JOINT: 3>, 'mjCNSTR_LIMIT_TENDON': <mjtConstraint.mjCNSTR_LIMIT_TENDON: 4>, 'mjCNSTR_CONTACT_FRICTIONLESS': <mjtConstraint.mjCNSTR_CONTACT_FRICTIONLESS: 5>, 'mjCNSTR_CONTACT_PYRAMIDAL': <mjtConstraint.mjCNSTR_CONTACT_PYRAMIDAL: 6>, 'mjCNSTR_CONTACT_ELLIPTIC': <mjtConstraint.mjCNSTR_CONTACT_ELLIPTIC: 7>}
    mjCNSTR_CONTACT_ELLIPTIC: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_CONTACT_ELLIPTIC: 7>
    mjCNSTR_CONTACT_FRICTIONLESS: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_CONTACT_FRICTIONLESS: 5>
    mjCNSTR_CONTACT_PYRAMIDAL: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_CONTACT_PYRAMIDAL: 6>
    mjCNSTR_EQUALITY: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_EQUALITY: 0>
    mjCNSTR_FRICTION_DOF: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_FRICTION_DOF: 1>
    mjCNSTR_FRICTION_TENDON: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_FRICTION_TENDON: 2>
    mjCNSTR_LIMIT_JOINT: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_LIMIT_JOINT: 3>
    mjCNSTR_LIMIT_TENDON: typing.ClassVar[mjtConstraint]  # value = <mjtConstraint.mjCNSTR_LIMIT_TENDON: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtConstraintState:
    """
    Members:
    
      mjCNSTRSTATE_SATISFIED
    
      mjCNSTRSTATE_QUADRATIC
    
      mjCNSTRSTATE_LINEARNEG
    
      mjCNSTRSTATE_LINEARPOS
    
      mjCNSTRSTATE_CONE
    """
    __members__: typing.ClassVar[dict[str, mjtConstraintState]]  # value = {'mjCNSTRSTATE_SATISFIED': <mjtConstraintState.mjCNSTRSTATE_SATISFIED: 0>, 'mjCNSTRSTATE_QUADRATIC': <mjtConstraintState.mjCNSTRSTATE_QUADRATIC: 1>, 'mjCNSTRSTATE_LINEARNEG': <mjtConstraintState.mjCNSTRSTATE_LINEARNEG: 2>, 'mjCNSTRSTATE_LINEARPOS': <mjtConstraintState.mjCNSTRSTATE_LINEARPOS: 3>, 'mjCNSTRSTATE_CONE': <mjtConstraintState.mjCNSTRSTATE_CONE: 4>}
    mjCNSTRSTATE_CONE: typing.ClassVar[mjtConstraintState]  # value = <mjtConstraintState.mjCNSTRSTATE_CONE: 4>
    mjCNSTRSTATE_LINEARNEG: typing.ClassVar[mjtConstraintState]  # value = <mjtConstraintState.mjCNSTRSTATE_LINEARNEG: 2>
    mjCNSTRSTATE_LINEARPOS: typing.ClassVar[mjtConstraintState]  # value = <mjtConstraintState.mjCNSTRSTATE_LINEARPOS: 3>
    mjCNSTRSTATE_QUADRATIC: typing.ClassVar[mjtConstraintState]  # value = <mjtConstraintState.mjCNSTRSTATE_QUADRATIC: 1>
    mjCNSTRSTATE_SATISFIED: typing.ClassVar[mjtConstraintState]  # value = <mjtConstraintState.mjCNSTRSTATE_SATISFIED: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtDataType:
    """
    Members:
    
      mjDATATYPE_REAL
    
      mjDATATYPE_POSITIVE
    
      mjDATATYPE_AXIS
    
      mjDATATYPE_QUATERNION
    """
    __members__: typing.ClassVar[dict[str, mjtDataType]]  # value = {'mjDATATYPE_REAL': <mjtDataType.mjDATATYPE_REAL: 0>, 'mjDATATYPE_POSITIVE': <mjtDataType.mjDATATYPE_POSITIVE: 1>, 'mjDATATYPE_AXIS': <mjtDataType.mjDATATYPE_AXIS: 2>, 'mjDATATYPE_QUATERNION': <mjtDataType.mjDATATYPE_QUATERNION: 3>}
    mjDATATYPE_AXIS: typing.ClassVar[mjtDataType]  # value = <mjtDataType.mjDATATYPE_AXIS: 2>
    mjDATATYPE_POSITIVE: typing.ClassVar[mjtDataType]  # value = <mjtDataType.mjDATATYPE_POSITIVE: 1>
    mjDATATYPE_QUATERNION: typing.ClassVar[mjtDataType]  # value = <mjtDataType.mjDATATYPE_QUATERNION: 3>
    mjDATATYPE_REAL: typing.ClassVar[mjtDataType]  # value = <mjtDataType.mjDATATYPE_REAL: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtDepthMap:
    """
    Members:
    
      mjDEPTH_ZERONEAR
    
      mjDEPTH_ZEROFAR
    """
    __members__: typing.ClassVar[dict[str, mjtDepthMap]]  # value = {'mjDEPTH_ZERONEAR': <mjtDepthMap.mjDEPTH_ZERONEAR: 0>, 'mjDEPTH_ZEROFAR': <mjtDepthMap.mjDEPTH_ZEROFAR: 1>}
    mjDEPTH_ZEROFAR: typing.ClassVar[mjtDepthMap]  # value = <mjtDepthMap.mjDEPTH_ZEROFAR: 1>
    mjDEPTH_ZERONEAR: typing.ClassVar[mjtDepthMap]  # value = <mjtDepthMap.mjDEPTH_ZERONEAR: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtDisableBit:
    """
    Members:
    
      mjDSBL_CONSTRAINT
    
      mjDSBL_EQUALITY
    
      mjDSBL_FRICTIONLOSS
    
      mjDSBL_LIMIT
    
      mjDSBL_CONTACT
    
      mjDSBL_PASSIVE
    
      mjDSBL_GRAVITY
    
      mjDSBL_CLAMPCTRL
    
      mjDSBL_WARMSTART
    
      mjDSBL_FILTERPARENT
    
      mjDSBL_ACTUATION
    
      mjDSBL_REFSAFE
    
      mjDSBL_SENSOR
    
      mjDSBL_MIDPHASE
    
      mjDSBL_EULERDAMP
    
      mjDSBL_AUTORESET
    
      mjNDISABLE
    """
    __members__: typing.ClassVar[dict[str, mjtDisableBit]]  # value = {'mjDSBL_CONSTRAINT': <mjtDisableBit.mjDSBL_CONSTRAINT: 1>, 'mjDSBL_EQUALITY': <mjtDisableBit.mjDSBL_EQUALITY: 2>, 'mjDSBL_FRICTIONLOSS': <mjtDisableBit.mjDSBL_FRICTIONLOSS: 4>, 'mjDSBL_LIMIT': <mjtDisableBit.mjDSBL_LIMIT: 8>, 'mjDSBL_CONTACT': <mjtDisableBit.mjDSBL_CONTACT: 16>, 'mjDSBL_PASSIVE': <mjtDisableBit.mjDSBL_PASSIVE: 32>, 'mjDSBL_GRAVITY': <mjtDisableBit.mjDSBL_GRAVITY: 64>, 'mjDSBL_CLAMPCTRL': <mjtDisableBit.mjDSBL_CLAMPCTRL: 128>, 'mjDSBL_WARMSTART': <mjtDisableBit.mjDSBL_WARMSTART: 256>, 'mjDSBL_FILTERPARENT': <mjtDisableBit.mjDSBL_FILTERPARENT: 512>, 'mjDSBL_ACTUATION': <mjtDisableBit.mjDSBL_ACTUATION: 1024>, 'mjDSBL_REFSAFE': <mjtDisableBit.mjDSBL_REFSAFE: 2048>, 'mjDSBL_SENSOR': <mjtDisableBit.mjDSBL_SENSOR: 4096>, 'mjDSBL_MIDPHASE': <mjtDisableBit.mjDSBL_MIDPHASE: 8192>, 'mjDSBL_EULERDAMP': <mjtDisableBit.mjDSBL_EULERDAMP: 16384>, 'mjDSBL_AUTORESET': <mjtDisableBit.mjDSBL_AUTORESET: 32768>, 'mjNDISABLE': <mjtDisableBit.mjDSBL_CONTACT: 16>}
    mjDSBL_ACTUATION: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_ACTUATION: 1024>
    mjDSBL_AUTORESET: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_AUTORESET: 32768>
    mjDSBL_CLAMPCTRL: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_CLAMPCTRL: 128>
    mjDSBL_CONSTRAINT: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_CONSTRAINT: 1>
    mjDSBL_CONTACT: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_CONTACT: 16>
    mjDSBL_EQUALITY: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_EQUALITY: 2>
    mjDSBL_EULERDAMP: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_EULERDAMP: 16384>
    mjDSBL_FILTERPARENT: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_FILTERPARENT: 512>
    mjDSBL_FRICTIONLOSS: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_FRICTIONLOSS: 4>
    mjDSBL_GRAVITY: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_GRAVITY: 64>
    mjDSBL_LIMIT: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_LIMIT: 8>
    mjDSBL_MIDPHASE: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_MIDPHASE: 8192>
    mjDSBL_PASSIVE: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_PASSIVE: 32>
    mjDSBL_REFSAFE: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_REFSAFE: 2048>
    mjDSBL_SENSOR: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_SENSOR: 4096>
    mjDSBL_WARMSTART: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_WARMSTART: 256>
    mjNDISABLE: typing.ClassVar[mjtDisableBit]  # value = <mjtDisableBit.mjDSBL_CONTACT: 16>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtDyn:
    """
    Members:
    
      mjDYN_NONE
    
      mjDYN_INTEGRATOR
    
      mjDYN_FILTER
    
      mjDYN_FILTEREXACT
    
      mjDYN_MUSCLE
    
      mjDYN_USER
    """
    __members__: typing.ClassVar[dict[str, mjtDyn]]  # value = {'mjDYN_NONE': <mjtDyn.mjDYN_NONE: 0>, 'mjDYN_INTEGRATOR': <mjtDyn.mjDYN_INTEGRATOR: 1>, 'mjDYN_FILTER': <mjtDyn.mjDYN_FILTER: 2>, 'mjDYN_FILTEREXACT': <mjtDyn.mjDYN_FILTEREXACT: 3>, 'mjDYN_MUSCLE': <mjtDyn.mjDYN_MUSCLE: 4>, 'mjDYN_USER': <mjtDyn.mjDYN_USER: 5>}
    mjDYN_FILTER: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_FILTER: 2>
    mjDYN_FILTEREXACT: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_FILTEREXACT: 3>
    mjDYN_INTEGRATOR: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_INTEGRATOR: 1>
    mjDYN_MUSCLE: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_MUSCLE: 4>
    mjDYN_NONE: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_NONE: 0>
    mjDYN_USER: typing.ClassVar[mjtDyn]  # value = <mjtDyn.mjDYN_USER: 5>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtEnableBit:
    """
    Members:
    
      mjENBL_OVERRIDE
    
      mjENBL_ENERGY
    
      mjENBL_FWDINV
    
      mjENBL_INVDISCRETE
    
      mjENBL_MULTICCD
    
      mjENBL_ISLAND
    
      mjENBL_NATIVECCD
    
      mjNENABLE
    """
    __members__: typing.ClassVar[dict[str, mjtEnableBit]]  # value = {'mjENBL_OVERRIDE': <mjtEnableBit.mjENBL_OVERRIDE: 1>, 'mjENBL_ENERGY': <mjtEnableBit.mjENBL_ENERGY: 2>, 'mjENBL_FWDINV': <mjtEnableBit.mjENBL_FWDINV: 4>, 'mjENBL_INVDISCRETE': <mjtEnableBit.mjENBL_INVDISCRETE: 8>, 'mjENBL_MULTICCD': <mjtEnableBit.mjENBL_MULTICCD: 16>, 'mjENBL_ISLAND': <mjtEnableBit.mjENBL_ISLAND: 32>, 'mjENBL_NATIVECCD': <mjtEnableBit.mjENBL_NATIVECCD: 64>, 'mjNENABLE': <mjtEnableBit.mjNENABLE: 7>}
    mjENBL_ENERGY: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_ENERGY: 2>
    mjENBL_FWDINV: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_FWDINV: 4>
    mjENBL_INVDISCRETE: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_INVDISCRETE: 8>
    mjENBL_ISLAND: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_ISLAND: 32>
    mjENBL_MULTICCD: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_MULTICCD: 16>
    mjENBL_NATIVECCD: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_NATIVECCD: 64>
    mjENBL_OVERRIDE: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjENBL_OVERRIDE: 1>
    mjNENABLE: typing.ClassVar[mjtEnableBit]  # value = <mjtEnableBit.mjNENABLE: 7>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtEq:
    """
    Members:
    
      mjEQ_CONNECT
    
      mjEQ_WELD
    
      mjEQ_JOINT
    
      mjEQ_TENDON
    
      mjEQ_FLEX
    
      mjEQ_DISTANCE
    """
    __members__: typing.ClassVar[dict[str, mjtEq]]  # value = {'mjEQ_CONNECT': <mjtEq.mjEQ_CONNECT: 0>, 'mjEQ_WELD': <mjtEq.mjEQ_WELD: 1>, 'mjEQ_JOINT': <mjtEq.mjEQ_JOINT: 2>, 'mjEQ_TENDON': <mjtEq.mjEQ_TENDON: 3>, 'mjEQ_FLEX': <mjtEq.mjEQ_FLEX: 4>, 'mjEQ_DISTANCE': <mjtEq.mjEQ_DISTANCE: 5>}
    mjEQ_CONNECT: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_CONNECT: 0>
    mjEQ_DISTANCE: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_DISTANCE: 5>
    mjEQ_FLEX: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_FLEX: 4>
    mjEQ_JOINT: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_JOINT: 2>
    mjEQ_TENDON: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_TENDON: 3>
    mjEQ_WELD: typing.ClassVar[mjtEq]  # value = <mjtEq.mjEQ_WELD: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtEvent:
    """
    Members:
    
      mjEVENT_NONE
    
      mjEVENT_MOVE
    
      mjEVENT_PRESS
    
      mjEVENT_RELEASE
    
      mjEVENT_SCROLL
    
      mjEVENT_KEY
    
      mjEVENT_RESIZE
    
      mjEVENT_REDRAW
    
      mjEVENT_FILESDROP
    """
    __members__: typing.ClassVar[dict[str, mjtEvent]]  # value = {'mjEVENT_NONE': <mjtEvent.mjEVENT_NONE: 0>, 'mjEVENT_MOVE': <mjtEvent.mjEVENT_MOVE: 1>, 'mjEVENT_PRESS': <mjtEvent.mjEVENT_PRESS: 2>, 'mjEVENT_RELEASE': <mjtEvent.mjEVENT_RELEASE: 3>, 'mjEVENT_SCROLL': <mjtEvent.mjEVENT_SCROLL: 4>, 'mjEVENT_KEY': <mjtEvent.mjEVENT_KEY: 5>, 'mjEVENT_RESIZE': <mjtEvent.mjEVENT_RESIZE: 6>, 'mjEVENT_REDRAW': <mjtEvent.mjEVENT_REDRAW: 7>, 'mjEVENT_FILESDROP': <mjtEvent.mjEVENT_FILESDROP: 8>}
    mjEVENT_FILESDROP: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_FILESDROP: 8>
    mjEVENT_KEY: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_KEY: 5>
    mjEVENT_MOVE: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_MOVE: 1>
    mjEVENT_NONE: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_NONE: 0>
    mjEVENT_PRESS: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_PRESS: 2>
    mjEVENT_REDRAW: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_REDRAW: 7>
    mjEVENT_RELEASE: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_RELEASE: 3>
    mjEVENT_RESIZE: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_RESIZE: 6>
    mjEVENT_SCROLL: typing.ClassVar[mjtEvent]  # value = <mjtEvent.mjEVENT_SCROLL: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtFlexSelf:
    """
    Members:
    
      mjFLEXSELF_NONE
    
      mjFLEXSELF_NARROW
    
      mjFLEXSELF_BVH
    
      mjFLEXSELF_SAP
    
      mjFLEXSELF_AUTO
    """
    __members__: typing.ClassVar[dict[str, mjtFlexSelf]]  # value = {'mjFLEXSELF_NONE': <mjtFlexSelf.mjFLEXSELF_NONE: 0>, 'mjFLEXSELF_NARROW': <mjtFlexSelf.mjFLEXSELF_NARROW: 1>, 'mjFLEXSELF_BVH': <mjtFlexSelf.mjFLEXSELF_BVH: 2>, 'mjFLEXSELF_SAP': <mjtFlexSelf.mjFLEXSELF_SAP: 3>, 'mjFLEXSELF_AUTO': <mjtFlexSelf.mjFLEXSELF_AUTO: 4>}
    mjFLEXSELF_AUTO: typing.ClassVar[mjtFlexSelf]  # value = <mjtFlexSelf.mjFLEXSELF_AUTO: 4>
    mjFLEXSELF_BVH: typing.ClassVar[mjtFlexSelf]  # value = <mjtFlexSelf.mjFLEXSELF_BVH: 2>
    mjFLEXSELF_NARROW: typing.ClassVar[mjtFlexSelf]  # value = <mjtFlexSelf.mjFLEXSELF_NARROW: 1>
    mjFLEXSELF_NONE: typing.ClassVar[mjtFlexSelf]  # value = <mjtFlexSelf.mjFLEXSELF_NONE: 0>
    mjFLEXSELF_SAP: typing.ClassVar[mjtFlexSelf]  # value = <mjtFlexSelf.mjFLEXSELF_SAP: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtFont:
    """
    Members:
    
      mjFONT_NORMAL
    
      mjFONT_SHADOW
    
      mjFONT_BIG
    """
    __members__: typing.ClassVar[dict[str, mjtFont]]  # value = {'mjFONT_NORMAL': <mjtFont.mjFONT_NORMAL: 0>, 'mjFONT_SHADOW': <mjtFont.mjFONT_SHADOW: 1>, 'mjFONT_BIG': <mjtFont.mjFONT_BIG: 2>}
    mjFONT_BIG: typing.ClassVar[mjtFont]  # value = <mjtFont.mjFONT_BIG: 2>
    mjFONT_NORMAL: typing.ClassVar[mjtFont]  # value = <mjtFont.mjFONT_NORMAL: 0>
    mjFONT_SHADOW: typing.ClassVar[mjtFont]  # value = <mjtFont.mjFONT_SHADOW: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtFontScale:
    """
    Members:
    
      mjFONTSCALE_50
    
      mjFONTSCALE_100
    
      mjFONTSCALE_150
    
      mjFONTSCALE_200
    
      mjFONTSCALE_250
    
      mjFONTSCALE_300
    """
    __members__: typing.ClassVar[dict[str, mjtFontScale]]  # value = {'mjFONTSCALE_50': <mjtFontScale.mjFONTSCALE_50: 50>, 'mjFONTSCALE_100': <mjtFontScale.mjFONTSCALE_100: 100>, 'mjFONTSCALE_150': <mjtFontScale.mjFONTSCALE_150: 150>, 'mjFONTSCALE_200': <mjtFontScale.mjFONTSCALE_200: 200>, 'mjFONTSCALE_250': <mjtFontScale.mjFONTSCALE_250: 250>, 'mjFONTSCALE_300': <mjtFontScale.mjFONTSCALE_300: 300>}
    mjFONTSCALE_100: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_100: 100>
    mjFONTSCALE_150: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_150: 150>
    mjFONTSCALE_200: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_200: 200>
    mjFONTSCALE_250: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_250: 250>
    mjFONTSCALE_300: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_300: 300>
    mjFONTSCALE_50: typing.ClassVar[mjtFontScale]  # value = <mjtFontScale.mjFONTSCALE_50: 50>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtFrame:
    """
    Members:
    
      mjFRAME_NONE
    
      mjFRAME_BODY
    
      mjFRAME_GEOM
    
      mjFRAME_SITE
    
      mjFRAME_CAMERA
    
      mjFRAME_LIGHT
    
      mjFRAME_CONTACT
    
      mjFRAME_WORLD
    
      mjNFRAME
    """
    __members__: typing.ClassVar[dict[str, mjtFrame]]  # value = {'mjFRAME_NONE': <mjtFrame.mjFRAME_NONE: 0>, 'mjFRAME_BODY': <mjtFrame.mjFRAME_BODY: 1>, 'mjFRAME_GEOM': <mjtFrame.mjFRAME_GEOM: 2>, 'mjFRAME_SITE': <mjtFrame.mjFRAME_SITE: 3>, 'mjFRAME_CAMERA': <mjtFrame.mjFRAME_CAMERA: 4>, 'mjFRAME_LIGHT': <mjtFrame.mjFRAME_LIGHT: 5>, 'mjFRAME_CONTACT': <mjtFrame.mjFRAME_CONTACT: 6>, 'mjFRAME_WORLD': <mjtFrame.mjFRAME_WORLD: 7>, 'mjNFRAME': <mjtFrame.mjNFRAME: 8>}
    mjFRAME_BODY: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_BODY: 1>
    mjFRAME_CAMERA: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_CAMERA: 4>
    mjFRAME_CONTACT: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_CONTACT: 6>
    mjFRAME_GEOM: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_GEOM: 2>
    mjFRAME_LIGHT: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_LIGHT: 5>
    mjFRAME_NONE: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_NONE: 0>
    mjFRAME_SITE: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_SITE: 3>
    mjFRAME_WORLD: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjFRAME_WORLD: 7>
    mjNFRAME: typing.ClassVar[mjtFrame]  # value = <mjtFrame.mjNFRAME: 8>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtFramebuffer:
    """
    Members:
    
      mjFB_WINDOW
    
      mjFB_OFFSCREEN
    """
    __members__: typing.ClassVar[dict[str, mjtFramebuffer]]  # value = {'mjFB_WINDOW': <mjtFramebuffer.mjFB_WINDOW: 0>, 'mjFB_OFFSCREEN': <mjtFramebuffer.mjFB_OFFSCREEN: 1>}
    mjFB_OFFSCREEN: typing.ClassVar[mjtFramebuffer]  # value = <mjtFramebuffer.mjFB_OFFSCREEN: 1>
    mjFB_WINDOW: typing.ClassVar[mjtFramebuffer]  # value = <mjtFramebuffer.mjFB_WINDOW: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtGain:
    """
    Members:
    
      mjGAIN_FIXED
    
      mjGAIN_AFFINE
    
      mjGAIN_MUSCLE
    
      mjGAIN_USER
    """
    __members__: typing.ClassVar[dict[str, mjtGain]]  # value = {'mjGAIN_FIXED': <mjtGain.mjGAIN_FIXED: 0>, 'mjGAIN_AFFINE': <mjtGain.mjGAIN_AFFINE: 1>, 'mjGAIN_MUSCLE': <mjtGain.mjGAIN_MUSCLE: 2>, 'mjGAIN_USER': <mjtGain.mjGAIN_USER: 3>}
    mjGAIN_AFFINE: typing.ClassVar[mjtGain]  # value = <mjtGain.mjGAIN_AFFINE: 1>
    mjGAIN_FIXED: typing.ClassVar[mjtGain]  # value = <mjtGain.mjGAIN_FIXED: 0>
    mjGAIN_MUSCLE: typing.ClassVar[mjtGain]  # value = <mjtGain.mjGAIN_MUSCLE: 2>
    mjGAIN_USER: typing.ClassVar[mjtGain]  # value = <mjtGain.mjGAIN_USER: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtGeom:
    """
    Members:
    
      mjGEOM_PLANE
    
      mjGEOM_HFIELD
    
      mjGEOM_SPHERE
    
      mjGEOM_CAPSULE
    
      mjGEOM_ELLIPSOID
    
      mjGEOM_CYLINDER
    
      mjGEOM_BOX
    
      mjGEOM_MESH
    
      mjGEOM_SDF
    
      mjNGEOMTYPES
    
      mjGEOM_ARROW
    
      mjGEOM_ARROW1
    
      mjGEOM_ARROW2
    
      mjGEOM_LINE
    
      mjGEOM_LINEBOX
    
      mjGEOM_FLEX
    
      mjGEOM_SKIN
    
      mjGEOM_LABEL
    
      mjGEOM_TRIANGLE
    
      mjGEOM_NONE
    """
    __members__: typing.ClassVar[dict[str, mjtGeom]]  # value = {'mjGEOM_PLANE': <mjtGeom.mjGEOM_PLANE: 0>, 'mjGEOM_HFIELD': <mjtGeom.mjGEOM_HFIELD: 1>, 'mjGEOM_SPHERE': <mjtGeom.mjGEOM_SPHERE: 2>, 'mjGEOM_CAPSULE': <mjtGeom.mjGEOM_CAPSULE: 3>, 'mjGEOM_ELLIPSOID': <mjtGeom.mjGEOM_ELLIPSOID: 4>, 'mjGEOM_CYLINDER': <mjtGeom.mjGEOM_CYLINDER: 5>, 'mjGEOM_BOX': <mjtGeom.mjGEOM_BOX: 6>, 'mjGEOM_MESH': <mjtGeom.mjGEOM_MESH: 7>, 'mjGEOM_SDF': <mjtGeom.mjGEOM_SDF: 8>, 'mjNGEOMTYPES': <mjtGeom.mjNGEOMTYPES: 9>, 'mjGEOM_ARROW': <mjtGeom.mjGEOM_ARROW: 100>, 'mjGEOM_ARROW1': <mjtGeom.mjGEOM_ARROW1: 101>, 'mjGEOM_ARROW2': <mjtGeom.mjGEOM_ARROW2: 102>, 'mjGEOM_LINE': <mjtGeom.mjGEOM_LINE: 103>, 'mjGEOM_LINEBOX': <mjtGeom.mjGEOM_LINEBOX: 104>, 'mjGEOM_FLEX': <mjtGeom.mjGEOM_FLEX: 105>, 'mjGEOM_SKIN': <mjtGeom.mjGEOM_SKIN: 106>, 'mjGEOM_LABEL': <mjtGeom.mjGEOM_LABEL: 107>, 'mjGEOM_TRIANGLE': <mjtGeom.mjGEOM_TRIANGLE: 108>, 'mjGEOM_NONE': <mjtGeom.mjGEOM_NONE: 1001>}
    mjGEOM_ARROW: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_ARROW: 100>
    mjGEOM_ARROW1: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_ARROW1: 101>
    mjGEOM_ARROW2: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_ARROW2: 102>
    mjGEOM_BOX: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_BOX: 6>
    mjGEOM_CAPSULE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_CAPSULE: 3>
    mjGEOM_CYLINDER: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_CYLINDER: 5>
    mjGEOM_ELLIPSOID: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_ELLIPSOID: 4>
    mjGEOM_FLEX: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_FLEX: 105>
    mjGEOM_HFIELD: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_HFIELD: 1>
    mjGEOM_LABEL: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_LABEL: 107>
    mjGEOM_LINE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_LINE: 103>
    mjGEOM_LINEBOX: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_LINEBOX: 104>
    mjGEOM_MESH: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_MESH: 7>
    mjGEOM_NONE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_NONE: 1001>
    mjGEOM_PLANE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_PLANE: 0>
    mjGEOM_SDF: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_SDF: 8>
    mjGEOM_SKIN: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_SKIN: 106>
    mjGEOM_SPHERE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_SPHERE: 2>
    mjGEOM_TRIANGLE: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjGEOM_TRIANGLE: 108>
    mjNGEOMTYPES: typing.ClassVar[mjtGeom]  # value = <mjtGeom.mjNGEOMTYPES: 9>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtGeomInertia:
    """
    Members:
    
      mjINERTIA_VOLUME
    
      mjINERTIA_SHELL
    """
    __members__: typing.ClassVar[dict[str, mjtGeomInertia]]  # value = {'mjINERTIA_VOLUME': <mjtGeomInertia.mjINERTIA_VOLUME: 0>, 'mjINERTIA_SHELL': <mjtGeomInertia.mjINERTIA_SHELL: 1>}
    mjINERTIA_SHELL: typing.ClassVar[mjtGeomInertia]  # value = <mjtGeomInertia.mjINERTIA_SHELL: 1>
    mjINERTIA_VOLUME: typing.ClassVar[mjtGeomInertia]  # value = <mjtGeomInertia.mjINERTIA_VOLUME: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtGridPos:
    """
    Members:
    
      mjGRID_TOPLEFT
    
      mjGRID_TOPRIGHT
    
      mjGRID_BOTTOMLEFT
    
      mjGRID_BOTTOMRIGHT
    
      mjGRID_TOP
    
      mjGRID_BOTTOM
    
      mjGRID_LEFT
    
      mjGRID_RIGHT
    """
    __members__: typing.ClassVar[dict[str, mjtGridPos]]  # value = {'mjGRID_TOPLEFT': <mjtGridPos.mjGRID_TOPLEFT: 0>, 'mjGRID_TOPRIGHT': <mjtGridPos.mjGRID_TOPRIGHT: 1>, 'mjGRID_BOTTOMLEFT': <mjtGridPos.mjGRID_BOTTOMLEFT: 2>, 'mjGRID_BOTTOMRIGHT': <mjtGridPos.mjGRID_BOTTOMRIGHT: 3>, 'mjGRID_TOP': <mjtGridPos.mjGRID_TOP: 4>, 'mjGRID_BOTTOM': <mjtGridPos.mjGRID_BOTTOM: 5>, 'mjGRID_LEFT': <mjtGridPos.mjGRID_LEFT: 6>, 'mjGRID_RIGHT': <mjtGridPos.mjGRID_RIGHT: 7>}
    mjGRID_BOTTOM: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_BOTTOM: 5>
    mjGRID_BOTTOMLEFT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_BOTTOMLEFT: 2>
    mjGRID_BOTTOMRIGHT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_BOTTOMRIGHT: 3>
    mjGRID_LEFT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_LEFT: 6>
    mjGRID_RIGHT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_RIGHT: 7>
    mjGRID_TOP: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_TOP: 4>
    mjGRID_TOPLEFT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_TOPLEFT: 0>
    mjGRID_TOPRIGHT: typing.ClassVar[mjtGridPos]  # value = <mjtGridPos.mjGRID_TOPRIGHT: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtInertiaFromGeom:
    """
    Members:
    
      mjINERTIAFROMGEOM_FALSE
    
      mjINERTIAFROMGEOM_TRUE
    
      mjINERTIAFROMGEOM_AUTO
    """
    __members__: typing.ClassVar[dict[str, mjtInertiaFromGeom]]  # value = {'mjINERTIAFROMGEOM_FALSE': <mjtInertiaFromGeom.mjINERTIAFROMGEOM_FALSE: 0>, 'mjINERTIAFROMGEOM_TRUE': <mjtInertiaFromGeom.mjINERTIAFROMGEOM_TRUE: 1>, 'mjINERTIAFROMGEOM_AUTO': <mjtInertiaFromGeom.mjINERTIAFROMGEOM_AUTO: 2>}
    mjINERTIAFROMGEOM_AUTO: typing.ClassVar[mjtInertiaFromGeom]  # value = <mjtInertiaFromGeom.mjINERTIAFROMGEOM_AUTO: 2>
    mjINERTIAFROMGEOM_FALSE: typing.ClassVar[mjtInertiaFromGeom]  # value = <mjtInertiaFromGeom.mjINERTIAFROMGEOM_FALSE: 0>
    mjINERTIAFROMGEOM_TRUE: typing.ClassVar[mjtInertiaFromGeom]  # value = <mjtInertiaFromGeom.mjINERTIAFROMGEOM_TRUE: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtIntegrator:
    """
    Members:
    
      mjINT_EULER
    
      mjINT_RK4
    
      mjINT_IMPLICIT
    
      mjINT_IMPLICITFAST
    """
    __members__: typing.ClassVar[dict[str, mjtIntegrator]]  # value = {'mjINT_EULER': <mjtIntegrator.mjINT_EULER: 0>, 'mjINT_RK4': <mjtIntegrator.mjINT_RK4: 1>, 'mjINT_IMPLICIT': <mjtIntegrator.mjINT_IMPLICIT: 2>, 'mjINT_IMPLICITFAST': <mjtIntegrator.mjINT_IMPLICITFAST: 3>}
    mjINT_EULER: typing.ClassVar[mjtIntegrator]  # value = <mjtIntegrator.mjINT_EULER: 0>
    mjINT_IMPLICIT: typing.ClassVar[mjtIntegrator]  # value = <mjtIntegrator.mjINT_IMPLICIT: 2>
    mjINT_IMPLICITFAST: typing.ClassVar[mjtIntegrator]  # value = <mjtIntegrator.mjINT_IMPLICITFAST: 3>
    mjINT_RK4: typing.ClassVar[mjtIntegrator]  # value = <mjtIntegrator.mjINT_RK4: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtItem:
    """
    Members:
    
      mjITEM_END
    
      mjITEM_SECTION
    
      mjITEM_SEPARATOR
    
      mjITEM_STATIC
    
      mjITEM_BUTTON
    
      mjITEM_CHECKINT
    
      mjITEM_CHECKBYTE
    
      mjITEM_RADIO
    
      mjITEM_RADIOLINE
    
      mjITEM_SELECT
    
      mjITEM_SLIDERINT
    
      mjITEM_SLIDERNUM
    
      mjITEM_EDITINT
    
      mjITEM_EDITNUM
    
      mjITEM_EDITFLOAT
    
      mjITEM_EDITTXT
    
      mjNITEM
    """
    __members__: typing.ClassVar[dict[str, mjtItem]]  # value = {'mjITEM_END': <mjtItem.mjITEM_END: -2>, 'mjITEM_SECTION': <mjtItem.mjITEM_SECTION: -1>, 'mjITEM_SEPARATOR': <mjtItem.mjITEM_SEPARATOR: 0>, 'mjITEM_STATIC': <mjtItem.mjITEM_STATIC: 1>, 'mjITEM_BUTTON': <mjtItem.mjITEM_BUTTON: 2>, 'mjITEM_CHECKINT': <mjtItem.mjITEM_CHECKINT: 3>, 'mjITEM_CHECKBYTE': <mjtItem.mjITEM_CHECKBYTE: 4>, 'mjITEM_RADIO': <mjtItem.mjITEM_RADIO: 5>, 'mjITEM_RADIOLINE': <mjtItem.mjITEM_RADIOLINE: 6>, 'mjITEM_SELECT': <mjtItem.mjITEM_SELECT: 7>, 'mjITEM_SLIDERINT': <mjtItem.mjITEM_SLIDERINT: 8>, 'mjITEM_SLIDERNUM': <mjtItem.mjITEM_SLIDERNUM: 9>, 'mjITEM_EDITINT': <mjtItem.mjITEM_EDITINT: 10>, 'mjITEM_EDITNUM': <mjtItem.mjITEM_EDITNUM: 11>, 'mjITEM_EDITFLOAT': <mjtItem.mjITEM_EDITFLOAT: 12>, 'mjITEM_EDITTXT': <mjtItem.mjITEM_EDITTXT: 13>, 'mjNITEM': <mjtItem.mjNITEM: 14>}
    mjITEM_BUTTON: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_BUTTON: 2>
    mjITEM_CHECKBYTE: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_CHECKBYTE: 4>
    mjITEM_CHECKINT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_CHECKINT: 3>
    mjITEM_EDITFLOAT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_EDITFLOAT: 12>
    mjITEM_EDITINT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_EDITINT: 10>
    mjITEM_EDITNUM: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_EDITNUM: 11>
    mjITEM_EDITTXT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_EDITTXT: 13>
    mjITEM_END: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_END: -2>
    mjITEM_RADIO: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_RADIO: 5>
    mjITEM_RADIOLINE: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_RADIOLINE: 6>
    mjITEM_SECTION: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_SECTION: -1>
    mjITEM_SELECT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_SELECT: 7>
    mjITEM_SEPARATOR: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_SEPARATOR: 0>
    mjITEM_SLIDERINT: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_SLIDERINT: 8>
    mjITEM_SLIDERNUM: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_SLIDERNUM: 9>
    mjITEM_STATIC: typing.ClassVar[mjtItem]  # value = <mjtItem.mjITEM_STATIC: 1>
    mjNITEM: typing.ClassVar[mjtItem]  # value = <mjtItem.mjNITEM: 14>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtJacobian:
    """
    Members:
    
      mjJAC_DENSE
    
      mjJAC_SPARSE
    
      mjJAC_AUTO
    """
    __members__: typing.ClassVar[dict[str, mjtJacobian]]  # value = {'mjJAC_DENSE': <mjtJacobian.mjJAC_DENSE: 0>, 'mjJAC_SPARSE': <mjtJacobian.mjJAC_SPARSE: 1>, 'mjJAC_AUTO': <mjtJacobian.mjJAC_AUTO: 2>}
    mjJAC_AUTO: typing.ClassVar[mjtJacobian]  # value = <mjtJacobian.mjJAC_AUTO: 2>
    mjJAC_DENSE: typing.ClassVar[mjtJacobian]  # value = <mjtJacobian.mjJAC_DENSE: 0>
    mjJAC_SPARSE: typing.ClassVar[mjtJacobian]  # value = <mjtJacobian.mjJAC_SPARSE: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtJoint:
    """
    Members:
    
      mjJNT_FREE
    
      mjJNT_BALL
    
      mjJNT_SLIDE
    
      mjJNT_HINGE
    """
    __members__: typing.ClassVar[dict[str, mjtJoint]]  # value = {'mjJNT_FREE': <mjtJoint.mjJNT_FREE: 0>, 'mjJNT_BALL': <mjtJoint.mjJNT_BALL: 1>, 'mjJNT_SLIDE': <mjtJoint.mjJNT_SLIDE: 2>, 'mjJNT_HINGE': <mjtJoint.mjJNT_HINGE: 3>}
    mjJNT_BALL: typing.ClassVar[mjtJoint]  # value = <mjtJoint.mjJNT_BALL: 1>
    mjJNT_FREE: typing.ClassVar[mjtJoint]  # value = <mjtJoint.mjJNT_FREE: 0>
    mjJNT_HINGE: typing.ClassVar[mjtJoint]  # value = <mjtJoint.mjJNT_HINGE: 3>
    mjJNT_SLIDE: typing.ClassVar[mjtJoint]  # value = <mjtJoint.mjJNT_SLIDE: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtLRMode:
    """
    Members:
    
      mjLRMODE_NONE
    
      mjLRMODE_MUSCLE
    
      mjLRMODE_MUSCLEUSER
    
      mjLRMODE_ALL
    """
    __members__: typing.ClassVar[dict[str, mjtLRMode]]  # value = {'mjLRMODE_NONE': <mjtLRMode.mjLRMODE_NONE: 0>, 'mjLRMODE_MUSCLE': <mjtLRMode.mjLRMODE_MUSCLE: 1>, 'mjLRMODE_MUSCLEUSER': <mjtLRMode.mjLRMODE_MUSCLEUSER: 2>, 'mjLRMODE_ALL': <mjtLRMode.mjLRMODE_ALL: 3>}
    mjLRMODE_ALL: typing.ClassVar[mjtLRMode]  # value = <mjtLRMode.mjLRMODE_ALL: 3>
    mjLRMODE_MUSCLE: typing.ClassVar[mjtLRMode]  # value = <mjtLRMode.mjLRMODE_MUSCLE: 1>
    mjLRMODE_MUSCLEUSER: typing.ClassVar[mjtLRMode]  # value = <mjtLRMode.mjLRMODE_MUSCLEUSER: 2>
    mjLRMODE_NONE: typing.ClassVar[mjtLRMode]  # value = <mjtLRMode.mjLRMODE_NONE: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtLabel:
    """
    Members:
    
      mjLABEL_NONE
    
      mjLABEL_BODY
    
      mjLABEL_JOINT
    
      mjLABEL_GEOM
    
      mjLABEL_SITE
    
      mjLABEL_CAMERA
    
      mjLABEL_LIGHT
    
      mjLABEL_TENDON
    
      mjLABEL_ACTUATOR
    
      mjLABEL_CONSTRAINT
    
      mjLABEL_FLEX
    
      mjLABEL_SKIN
    
      mjLABEL_SELECTION
    
      mjLABEL_SELPNT
    
      mjLABEL_CONTACTPOINT
    
      mjLABEL_CONTACTFORCE
    
      mjLABEL_ISLAND
    
      mjNLABEL
    """
    __members__: typing.ClassVar[dict[str, mjtLabel]]  # value = {'mjLABEL_NONE': <mjtLabel.mjLABEL_NONE: 0>, 'mjLABEL_BODY': <mjtLabel.mjLABEL_BODY: 1>, 'mjLABEL_JOINT': <mjtLabel.mjLABEL_JOINT: 2>, 'mjLABEL_GEOM': <mjtLabel.mjLABEL_GEOM: 3>, 'mjLABEL_SITE': <mjtLabel.mjLABEL_SITE: 4>, 'mjLABEL_CAMERA': <mjtLabel.mjLABEL_CAMERA: 5>, 'mjLABEL_LIGHT': <mjtLabel.mjLABEL_LIGHT: 6>, 'mjLABEL_TENDON': <mjtLabel.mjLABEL_TENDON: 7>, 'mjLABEL_ACTUATOR': <mjtLabel.mjLABEL_ACTUATOR: 8>, 'mjLABEL_CONSTRAINT': <mjtLabel.mjLABEL_CONSTRAINT: 9>, 'mjLABEL_FLEX': <mjtLabel.mjLABEL_FLEX: 10>, 'mjLABEL_SKIN': <mjtLabel.mjLABEL_SKIN: 11>, 'mjLABEL_SELECTION': <mjtLabel.mjLABEL_SELECTION: 12>, 'mjLABEL_SELPNT': <mjtLabel.mjLABEL_SELPNT: 13>, 'mjLABEL_CONTACTPOINT': <mjtLabel.mjLABEL_CONTACTPOINT: 14>, 'mjLABEL_CONTACTFORCE': <mjtLabel.mjLABEL_CONTACTFORCE: 15>, 'mjLABEL_ISLAND': <mjtLabel.mjLABEL_ISLAND: 16>, 'mjNLABEL': <mjtLabel.mjNLABEL: 17>}
    mjLABEL_ACTUATOR: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_ACTUATOR: 8>
    mjLABEL_BODY: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_BODY: 1>
    mjLABEL_CAMERA: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_CAMERA: 5>
    mjLABEL_CONSTRAINT: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_CONSTRAINT: 9>
    mjLABEL_CONTACTFORCE: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_CONTACTFORCE: 15>
    mjLABEL_CONTACTPOINT: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_CONTACTPOINT: 14>
    mjLABEL_FLEX: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_FLEX: 10>
    mjLABEL_GEOM: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_GEOM: 3>
    mjLABEL_ISLAND: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_ISLAND: 16>
    mjLABEL_JOINT: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_JOINT: 2>
    mjLABEL_LIGHT: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_LIGHT: 6>
    mjLABEL_NONE: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_NONE: 0>
    mjLABEL_SELECTION: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_SELECTION: 12>
    mjLABEL_SELPNT: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_SELPNT: 13>
    mjLABEL_SITE: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_SITE: 4>
    mjLABEL_SKIN: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_SKIN: 11>
    mjLABEL_TENDON: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjLABEL_TENDON: 7>
    mjNLABEL: typing.ClassVar[mjtLabel]  # value = <mjtLabel.mjNLABEL: 17>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtLimited:
    """
    Members:
    
      mjLIMITED_FALSE
    
      mjLIMITED_TRUE
    
      mjLIMITED_AUTO
    """
    __members__: typing.ClassVar[dict[str, mjtLimited]]  # value = {'mjLIMITED_FALSE': <mjtLimited.mjLIMITED_FALSE: 0>, 'mjLIMITED_TRUE': <mjtLimited.mjLIMITED_TRUE: 1>, 'mjLIMITED_AUTO': <mjtLimited.mjLIMITED_AUTO: 2>}
    mjLIMITED_AUTO: typing.ClassVar[mjtLimited]  # value = <mjtLimited.mjLIMITED_AUTO: 2>
    mjLIMITED_FALSE: typing.ClassVar[mjtLimited]  # value = <mjtLimited.mjLIMITED_FALSE: 0>
    mjLIMITED_TRUE: typing.ClassVar[mjtLimited]  # value = <mjtLimited.mjLIMITED_TRUE: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtMark:
    """
    Members:
    
      mjMARK_NONE
    
      mjMARK_EDGE
    
      mjMARK_CROSS
    
      mjMARK_RANDOM
    """
    __members__: typing.ClassVar[dict[str, mjtMark]]  # value = {'mjMARK_NONE': <mjtMark.mjMARK_NONE: 0>, 'mjMARK_EDGE': <mjtMark.mjMARK_EDGE: 1>, 'mjMARK_CROSS': <mjtMark.mjMARK_CROSS: 2>, 'mjMARK_RANDOM': <mjtMark.mjMARK_RANDOM: 3>}
    mjMARK_CROSS: typing.ClassVar[mjtMark]  # value = <mjtMark.mjMARK_CROSS: 2>
    mjMARK_EDGE: typing.ClassVar[mjtMark]  # value = <mjtMark.mjMARK_EDGE: 1>
    mjMARK_NONE: typing.ClassVar[mjtMark]  # value = <mjtMark.mjMARK_NONE: 0>
    mjMARK_RANDOM: typing.ClassVar[mjtMark]  # value = <mjtMark.mjMARK_RANDOM: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtMeshInertia:
    """
    Members:
    
      mjINERTIA_CONVEX
    
      mjINERTIA_EXACT
    
      mjINERTIA_LEGACY
    """
    __members__: typing.ClassVar[dict[str, mjtMeshInertia]]  # value = {'mjINERTIA_CONVEX': <mjtMeshInertia.mjINERTIA_CONVEX: 0>, 'mjINERTIA_EXACT': <mjtMeshInertia.mjINERTIA_EXACT: 1>, 'mjINERTIA_LEGACY': <mjtMeshInertia.mjINERTIA_LEGACY: 2>}
    mjINERTIA_CONVEX: typing.ClassVar[mjtMeshInertia]  # value = <mjtMeshInertia.mjINERTIA_CONVEX: 0>
    mjINERTIA_EXACT: typing.ClassVar[mjtMeshInertia]  # value = <mjtMeshInertia.mjINERTIA_EXACT: 1>
    mjINERTIA_LEGACY: typing.ClassVar[mjtMeshInertia]  # value = <mjtMeshInertia.mjINERTIA_LEGACY: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtMouse:
    """
    Members:
    
      mjMOUSE_NONE
    
      mjMOUSE_ROTATE_V
    
      mjMOUSE_ROTATE_H
    
      mjMOUSE_MOVE_V
    
      mjMOUSE_MOVE_H
    
      mjMOUSE_ZOOM
    
      mjMOUSE_SELECT
    """
    __members__: typing.ClassVar[dict[str, mjtMouse]]  # value = {'mjMOUSE_NONE': <mjtMouse.mjMOUSE_NONE: 0>, 'mjMOUSE_ROTATE_V': <mjtMouse.mjMOUSE_ROTATE_V: 1>, 'mjMOUSE_ROTATE_H': <mjtMouse.mjMOUSE_ROTATE_H: 2>, 'mjMOUSE_MOVE_V': <mjtMouse.mjMOUSE_MOVE_V: 3>, 'mjMOUSE_MOVE_H': <mjtMouse.mjMOUSE_MOVE_H: 4>, 'mjMOUSE_ZOOM': <mjtMouse.mjMOUSE_ZOOM: 5>, 'mjMOUSE_SELECT': <mjtMouse.mjMOUSE_SELECT: 6>}
    mjMOUSE_MOVE_H: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_MOVE_H: 4>
    mjMOUSE_MOVE_V: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_MOVE_V: 3>
    mjMOUSE_NONE: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_NONE: 0>
    mjMOUSE_ROTATE_H: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_ROTATE_H: 2>
    mjMOUSE_ROTATE_V: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_ROTATE_V: 1>
    mjMOUSE_SELECT: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_SELECT: 6>
    mjMOUSE_ZOOM: typing.ClassVar[mjtMouse]  # value = <mjtMouse.mjMOUSE_ZOOM: 5>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtObj:
    """
    Members:
    
      mjOBJ_UNKNOWN
    
      mjOBJ_BODY
    
      mjOBJ_XBODY
    
      mjOBJ_JOINT
    
      mjOBJ_DOF
    
      mjOBJ_GEOM
    
      mjOBJ_SITE
    
      mjOBJ_CAMERA
    
      mjOBJ_LIGHT
    
      mjOBJ_FLEX
    
      mjOBJ_MESH
    
      mjOBJ_SKIN
    
      mjOBJ_HFIELD
    
      mjOBJ_TEXTURE
    
      mjOBJ_MATERIAL
    
      mjOBJ_PAIR
    
      mjOBJ_EXCLUDE
    
      mjOBJ_EQUALITY
    
      mjOBJ_TENDON
    
      mjOBJ_ACTUATOR
    
      mjOBJ_SENSOR
    
      mjOBJ_NUMERIC
    
      mjOBJ_TEXT
    
      mjOBJ_TUPLE
    
      mjOBJ_KEY
    
      mjOBJ_PLUGIN
    
      mjNOBJECT
    
      mjOBJ_FRAME
    """
    __members__: typing.ClassVar[dict[str, mjtObj]]  # value = {'mjOBJ_UNKNOWN': <mjtObj.mjOBJ_UNKNOWN: 0>, 'mjOBJ_BODY': <mjtObj.mjOBJ_BODY: 1>, 'mjOBJ_XBODY': <mjtObj.mjOBJ_XBODY: 2>, 'mjOBJ_JOINT': <mjtObj.mjOBJ_JOINT: 3>, 'mjOBJ_DOF': <mjtObj.mjOBJ_DOF: 4>, 'mjOBJ_GEOM': <mjtObj.mjOBJ_GEOM: 5>, 'mjOBJ_SITE': <mjtObj.mjOBJ_SITE: 6>, 'mjOBJ_CAMERA': <mjtObj.mjOBJ_CAMERA: 7>, 'mjOBJ_LIGHT': <mjtObj.mjOBJ_LIGHT: 8>, 'mjOBJ_FLEX': <mjtObj.mjOBJ_FLEX: 9>, 'mjOBJ_MESH': <mjtObj.mjOBJ_MESH: 10>, 'mjOBJ_SKIN': <mjtObj.mjOBJ_SKIN: 11>, 'mjOBJ_HFIELD': <mjtObj.mjOBJ_HFIELD: 12>, 'mjOBJ_TEXTURE': <mjtObj.mjOBJ_TEXTURE: 13>, 'mjOBJ_MATERIAL': <mjtObj.mjOBJ_MATERIAL: 14>, 'mjOBJ_PAIR': <mjtObj.mjOBJ_PAIR: 15>, 'mjOBJ_EXCLUDE': <mjtObj.mjOBJ_EXCLUDE: 16>, 'mjOBJ_EQUALITY': <mjtObj.mjOBJ_EQUALITY: 17>, 'mjOBJ_TENDON': <mjtObj.mjOBJ_TENDON: 18>, 'mjOBJ_ACTUATOR': <mjtObj.mjOBJ_ACTUATOR: 19>, 'mjOBJ_SENSOR': <mjtObj.mjOBJ_SENSOR: 20>, 'mjOBJ_NUMERIC': <mjtObj.mjOBJ_NUMERIC: 21>, 'mjOBJ_TEXT': <mjtObj.mjOBJ_TEXT: 22>, 'mjOBJ_TUPLE': <mjtObj.mjOBJ_TUPLE: 23>, 'mjOBJ_KEY': <mjtObj.mjOBJ_KEY: 24>, 'mjOBJ_PLUGIN': <mjtObj.mjOBJ_PLUGIN: 25>, 'mjNOBJECT': <mjtObj.mjNOBJECT: 26>, 'mjOBJ_FRAME': <mjtObj.mjOBJ_FRAME: 100>}
    mjNOBJECT: typing.ClassVar[mjtObj]  # value = <mjtObj.mjNOBJECT: 26>
    mjOBJ_ACTUATOR: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_ACTUATOR: 19>
    mjOBJ_BODY: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_BODY: 1>
    mjOBJ_CAMERA: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_CAMERA: 7>
    mjOBJ_DOF: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_DOF: 4>
    mjOBJ_EQUALITY: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_EQUALITY: 17>
    mjOBJ_EXCLUDE: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_EXCLUDE: 16>
    mjOBJ_FLEX: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_FLEX: 9>
    mjOBJ_FRAME: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_FRAME: 100>
    mjOBJ_GEOM: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_GEOM: 5>
    mjOBJ_HFIELD: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_HFIELD: 12>
    mjOBJ_JOINT: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_JOINT: 3>
    mjOBJ_KEY: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_KEY: 24>
    mjOBJ_LIGHT: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_LIGHT: 8>
    mjOBJ_MATERIAL: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_MATERIAL: 14>
    mjOBJ_MESH: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_MESH: 10>
    mjOBJ_NUMERIC: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_NUMERIC: 21>
    mjOBJ_PAIR: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_PAIR: 15>
    mjOBJ_PLUGIN: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_PLUGIN: 25>
    mjOBJ_SENSOR: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_SENSOR: 20>
    mjOBJ_SITE: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_SITE: 6>
    mjOBJ_SKIN: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_SKIN: 11>
    mjOBJ_TENDON: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_TENDON: 18>
    mjOBJ_TEXT: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_TEXT: 22>
    mjOBJ_TEXTURE: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_TEXTURE: 13>
    mjOBJ_TUPLE: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_TUPLE: 23>
    mjOBJ_UNKNOWN: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_UNKNOWN: 0>
    mjOBJ_XBODY: typing.ClassVar[mjtObj]  # value = <mjtObj.mjOBJ_XBODY: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtOrientation:
    """
    Members:
    
      mjORIENTATION_QUAT
    
      mjORIENTATION_AXISANGLE
    
      mjORIENTATION_XYAXES
    
      mjORIENTATION_ZAXIS
    
      mjORIENTATION_EULER
    """
    __members__: typing.ClassVar[dict[str, mjtOrientation]]  # value = {'mjORIENTATION_QUAT': <mjtOrientation.mjORIENTATION_QUAT: 0>, 'mjORIENTATION_AXISANGLE': <mjtOrientation.mjORIENTATION_AXISANGLE: 1>, 'mjORIENTATION_XYAXES': <mjtOrientation.mjORIENTATION_XYAXES: 2>, 'mjORIENTATION_ZAXIS': <mjtOrientation.mjORIENTATION_ZAXIS: 3>, 'mjORIENTATION_EULER': <mjtOrientation.mjORIENTATION_EULER: 4>}
    mjORIENTATION_AXISANGLE: typing.ClassVar[mjtOrientation]  # value = <mjtOrientation.mjORIENTATION_AXISANGLE: 1>
    mjORIENTATION_EULER: typing.ClassVar[mjtOrientation]  # value = <mjtOrientation.mjORIENTATION_EULER: 4>
    mjORIENTATION_QUAT: typing.ClassVar[mjtOrientation]  # value = <mjtOrientation.mjORIENTATION_QUAT: 0>
    mjORIENTATION_XYAXES: typing.ClassVar[mjtOrientation]  # value = <mjtOrientation.mjORIENTATION_XYAXES: 2>
    mjORIENTATION_ZAXIS: typing.ClassVar[mjtOrientation]  # value = <mjtOrientation.mjORIENTATION_ZAXIS: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtPertBit:
    """
    Members:
    
      mjPERT_TRANSLATE
    
      mjPERT_ROTATE
    """
    __members__: typing.ClassVar[dict[str, mjtPertBit]]  # value = {'mjPERT_TRANSLATE': <mjtPertBit.mjPERT_TRANSLATE: 1>, 'mjPERT_ROTATE': <mjtPertBit.mjPERT_ROTATE: 2>}
    mjPERT_ROTATE: typing.ClassVar[mjtPertBit]  # value = <mjtPertBit.mjPERT_ROTATE: 2>
    mjPERT_TRANSLATE: typing.ClassVar[mjtPertBit]  # value = <mjtPertBit.mjPERT_TRANSLATE: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtPluginCapabilityBit:
    """
    Members:
    
      mjPLUGIN_ACTUATOR
    
      mjPLUGIN_SENSOR
    
      mjPLUGIN_PASSIVE
    
      mjPLUGIN_SDF
    """
    __members__: typing.ClassVar[dict[str, mjtPluginCapabilityBit]]  # value = {'mjPLUGIN_ACTUATOR': <mjtPluginCapabilityBit.mjPLUGIN_ACTUATOR: 1>, 'mjPLUGIN_SENSOR': <mjtPluginCapabilityBit.mjPLUGIN_SENSOR: 2>, 'mjPLUGIN_PASSIVE': <mjtPluginCapabilityBit.mjPLUGIN_PASSIVE: 4>, 'mjPLUGIN_SDF': <mjtPluginCapabilityBit.mjPLUGIN_SDF: 8>}
    mjPLUGIN_ACTUATOR: typing.ClassVar[mjtPluginCapabilityBit]  # value = <mjtPluginCapabilityBit.mjPLUGIN_ACTUATOR: 1>
    mjPLUGIN_PASSIVE: typing.ClassVar[mjtPluginCapabilityBit]  # value = <mjtPluginCapabilityBit.mjPLUGIN_PASSIVE: 4>
    mjPLUGIN_SDF: typing.ClassVar[mjtPluginCapabilityBit]  # value = <mjtPluginCapabilityBit.mjPLUGIN_SDF: 8>
    mjPLUGIN_SENSOR: typing.ClassVar[mjtPluginCapabilityBit]  # value = <mjtPluginCapabilityBit.mjPLUGIN_SENSOR: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtRndFlag:
    """
    Members:
    
      mjRND_SHADOW
    
      mjRND_WIREFRAME
    
      mjRND_REFLECTION
    
      mjRND_ADDITIVE
    
      mjRND_SKYBOX
    
      mjRND_FOG
    
      mjRND_HAZE
    
      mjRND_SEGMENT
    
      mjRND_IDCOLOR
    
      mjRND_CULL_FACE
    
      mjNRNDFLAG
    """
    __members__: typing.ClassVar[dict[str, mjtRndFlag]]  # value = {'mjRND_SHADOW': <mjtRndFlag.mjRND_SHADOW: 0>, 'mjRND_WIREFRAME': <mjtRndFlag.mjRND_WIREFRAME: 1>, 'mjRND_REFLECTION': <mjtRndFlag.mjRND_REFLECTION: 2>, 'mjRND_ADDITIVE': <mjtRndFlag.mjRND_ADDITIVE: 3>, 'mjRND_SKYBOX': <mjtRndFlag.mjRND_SKYBOX: 4>, 'mjRND_FOG': <mjtRndFlag.mjRND_FOG: 5>, 'mjRND_HAZE': <mjtRndFlag.mjRND_HAZE: 6>, 'mjRND_SEGMENT': <mjtRndFlag.mjRND_SEGMENT: 7>, 'mjRND_IDCOLOR': <mjtRndFlag.mjRND_IDCOLOR: 8>, 'mjRND_CULL_FACE': <mjtRndFlag.mjRND_CULL_FACE: 9>, 'mjNRNDFLAG': <mjtRndFlag.mjNRNDFLAG: 10>}
    mjNRNDFLAG: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjNRNDFLAG: 10>
    mjRND_ADDITIVE: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_ADDITIVE: 3>
    mjRND_CULL_FACE: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_CULL_FACE: 9>
    mjRND_FOG: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_FOG: 5>
    mjRND_HAZE: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_HAZE: 6>
    mjRND_IDCOLOR: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_IDCOLOR: 8>
    mjRND_REFLECTION: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_REFLECTION: 2>
    mjRND_SEGMENT: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_SEGMENT: 7>
    mjRND_SHADOW: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_SHADOW: 0>
    mjRND_SKYBOX: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_SKYBOX: 4>
    mjRND_WIREFRAME: typing.ClassVar[mjtRndFlag]  # value = <mjtRndFlag.mjRND_WIREFRAME: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtSameFrame:
    """
    Members:
    
      mjSAMEFRAME_NONE
    
      mjSAMEFRAME_BODY
    
      mjSAMEFRAME_INERTIA
    
      mjSAMEFRAME_BODYROT
    
      mjSAMEFRAME_INERTIAROT
    """
    __members__: typing.ClassVar[dict[str, mjtSameFrame]]  # value = {'mjSAMEFRAME_NONE': <mjtSameFrame.mjSAMEFRAME_NONE: 0>, 'mjSAMEFRAME_BODY': <mjtSameFrame.mjSAMEFRAME_BODY: 1>, 'mjSAMEFRAME_INERTIA': <mjtSameFrame.mjSAMEFRAME_INERTIA: 2>, 'mjSAMEFRAME_BODYROT': <mjtSameFrame.mjSAMEFRAME_BODYROT: 3>, 'mjSAMEFRAME_INERTIAROT': <mjtSameFrame.mjSAMEFRAME_INERTIAROT: 4>}
    mjSAMEFRAME_BODY: typing.ClassVar[mjtSameFrame]  # value = <mjtSameFrame.mjSAMEFRAME_BODY: 1>
    mjSAMEFRAME_BODYROT: typing.ClassVar[mjtSameFrame]  # value = <mjtSameFrame.mjSAMEFRAME_BODYROT: 3>
    mjSAMEFRAME_INERTIA: typing.ClassVar[mjtSameFrame]  # value = <mjtSameFrame.mjSAMEFRAME_INERTIA: 2>
    mjSAMEFRAME_INERTIAROT: typing.ClassVar[mjtSameFrame]  # value = <mjtSameFrame.mjSAMEFRAME_INERTIAROT: 4>
    mjSAMEFRAME_NONE: typing.ClassVar[mjtSameFrame]  # value = <mjtSameFrame.mjSAMEFRAME_NONE: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtSection:
    """
    Members:
    
      mjSECT_CLOSED
    
      mjSECT_OPEN
    
      mjSECT_FIXED
    """
    __members__: typing.ClassVar[dict[str, mjtSection]]  # value = {'mjSECT_CLOSED': <mjtSection.mjSECT_CLOSED: 0>, 'mjSECT_OPEN': <mjtSection.mjSECT_OPEN: 1>, 'mjSECT_FIXED': <mjtSection.mjSECT_FIXED: 2>}
    mjSECT_CLOSED: typing.ClassVar[mjtSection]  # value = <mjtSection.mjSECT_CLOSED: 0>
    mjSECT_FIXED: typing.ClassVar[mjtSection]  # value = <mjtSection.mjSECT_FIXED: 2>
    mjSECT_OPEN: typing.ClassVar[mjtSection]  # value = <mjtSection.mjSECT_OPEN: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtSensor:
    """
    Members:
    
      mjSENS_TOUCH
    
      mjSENS_ACCELEROMETER
    
      mjSENS_VELOCIMETER
    
      mjSENS_GYRO
    
      mjSENS_FORCE
    
      mjSENS_TORQUE
    
      mjSENS_MAGNETOMETER
    
      mjSENS_RANGEFINDER
    
      mjSENS_CAMPROJECTION
    
      mjSENS_JOINTPOS
    
      mjSENS_JOINTVEL
    
      mjSENS_TENDONPOS
    
      mjSENS_TENDONVEL
    
      mjSENS_ACTUATORPOS
    
      mjSENS_ACTUATORVEL
    
      mjSENS_ACTUATORFRC
    
      mjSENS_JOINTACTFRC
    
      mjSENS_BALLQUAT
    
      mjSENS_BALLANGVEL
    
      mjSENS_JOINTLIMITPOS
    
      mjSENS_JOINTLIMITVEL
    
      mjSENS_JOINTLIMITFRC
    
      mjSENS_TENDONLIMITPOS
    
      mjSENS_TENDONLIMITVEL
    
      mjSENS_TENDONLIMITFRC
    
      mjSENS_FRAMEPOS
    
      mjSENS_FRAMEQUAT
    
      mjSENS_FRAMEXAXIS
    
      mjSENS_FRAMEYAXIS
    
      mjSENS_FRAMEZAXIS
    
      mjSENS_FRAMELINVEL
    
      mjSENS_FRAMEANGVEL
    
      mjSENS_FRAMELINACC
    
      mjSENS_FRAMEANGACC
    
      mjSENS_SUBTREECOM
    
      mjSENS_SUBTREELINVEL
    
      mjSENS_SUBTREEANGMOM
    
      mjSENS_GEOMDIST
    
      mjSENS_GEOMNORMAL
    
      mjSENS_GEOMFROMTO
    
      mjSENS_CLOCK
    
      mjSENS_PLUGIN
    
      mjSENS_USER
    """
    __members__: typing.ClassVar[dict[str, mjtSensor]]  # value = {'mjSENS_TOUCH': <mjtSensor.mjSENS_TOUCH: 0>, 'mjSENS_ACCELEROMETER': <mjtSensor.mjSENS_ACCELEROMETER: 1>, 'mjSENS_VELOCIMETER': <mjtSensor.mjSENS_VELOCIMETER: 2>, 'mjSENS_GYRO': <mjtSensor.mjSENS_GYRO: 3>, 'mjSENS_FORCE': <mjtSensor.mjSENS_FORCE: 4>, 'mjSENS_TORQUE': <mjtSensor.mjSENS_TORQUE: 5>, 'mjSENS_MAGNETOMETER': <mjtSensor.mjSENS_MAGNETOMETER: 6>, 'mjSENS_RANGEFINDER': <mjtSensor.mjSENS_RANGEFINDER: 7>, 'mjSENS_CAMPROJECTION': <mjtSensor.mjSENS_CAMPROJECTION: 8>, 'mjSENS_JOINTPOS': <mjtSensor.mjSENS_JOINTPOS: 9>, 'mjSENS_JOINTVEL': <mjtSensor.mjSENS_JOINTVEL: 10>, 'mjSENS_TENDONPOS': <mjtSensor.mjSENS_TENDONPOS: 11>, 'mjSENS_TENDONVEL': <mjtSensor.mjSENS_TENDONVEL: 12>, 'mjSENS_ACTUATORPOS': <mjtSensor.mjSENS_ACTUATORPOS: 13>, 'mjSENS_ACTUATORVEL': <mjtSensor.mjSENS_ACTUATORVEL: 14>, 'mjSENS_ACTUATORFRC': <mjtSensor.mjSENS_ACTUATORFRC: 15>, 'mjSENS_JOINTACTFRC': <mjtSensor.mjSENS_JOINTACTFRC: 16>, 'mjSENS_BALLQUAT': <mjtSensor.mjSENS_BALLQUAT: 17>, 'mjSENS_BALLANGVEL': <mjtSensor.mjSENS_BALLANGVEL: 18>, 'mjSENS_JOINTLIMITPOS': <mjtSensor.mjSENS_JOINTLIMITPOS: 19>, 'mjSENS_JOINTLIMITVEL': <mjtSensor.mjSENS_JOINTLIMITVEL: 20>, 'mjSENS_JOINTLIMITFRC': <mjtSensor.mjSENS_JOINTLIMITFRC: 21>, 'mjSENS_TENDONLIMITPOS': <mjtSensor.mjSENS_TENDONLIMITPOS: 22>, 'mjSENS_TENDONLIMITVEL': <mjtSensor.mjSENS_TENDONLIMITVEL: 23>, 'mjSENS_TENDONLIMITFRC': <mjtSensor.mjSENS_TENDONLIMITFRC: 24>, 'mjSENS_FRAMEPOS': <mjtSensor.mjSENS_FRAMEPOS: 25>, 'mjSENS_FRAMEQUAT': <mjtSensor.mjSENS_FRAMEQUAT: 26>, 'mjSENS_FRAMEXAXIS': <mjtSensor.mjSENS_FRAMEXAXIS: 27>, 'mjSENS_FRAMEYAXIS': <mjtSensor.mjSENS_FRAMEYAXIS: 28>, 'mjSENS_FRAMEZAXIS': <mjtSensor.mjSENS_FRAMEZAXIS: 29>, 'mjSENS_FRAMELINVEL': <mjtSensor.mjSENS_FRAMELINVEL: 30>, 'mjSENS_FRAMEANGVEL': <mjtSensor.mjSENS_FRAMEANGVEL: 31>, 'mjSENS_FRAMELINACC': <mjtSensor.mjSENS_FRAMELINACC: 32>, 'mjSENS_FRAMEANGACC': <mjtSensor.mjSENS_FRAMEANGACC: 33>, 'mjSENS_SUBTREECOM': <mjtSensor.mjSENS_SUBTREECOM: 34>, 'mjSENS_SUBTREELINVEL': <mjtSensor.mjSENS_SUBTREELINVEL: 35>, 'mjSENS_SUBTREEANGMOM': <mjtSensor.mjSENS_SUBTREEANGMOM: 36>, 'mjSENS_GEOMDIST': <mjtSensor.mjSENS_GEOMDIST: 37>, 'mjSENS_GEOMNORMAL': <mjtSensor.mjSENS_GEOMNORMAL: 38>, 'mjSENS_GEOMFROMTO': <mjtSensor.mjSENS_GEOMFROMTO: 39>, 'mjSENS_CLOCK': <mjtSensor.mjSENS_CLOCK: 40>, 'mjSENS_PLUGIN': <mjtSensor.mjSENS_PLUGIN: 41>, 'mjSENS_USER': <mjtSensor.mjSENS_USER: 42>}
    mjSENS_ACCELEROMETER: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_ACCELEROMETER: 1>
    mjSENS_ACTUATORFRC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_ACTUATORFRC: 15>
    mjSENS_ACTUATORPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_ACTUATORPOS: 13>
    mjSENS_ACTUATORVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_ACTUATORVEL: 14>
    mjSENS_BALLANGVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_BALLANGVEL: 18>
    mjSENS_BALLQUAT: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_BALLQUAT: 17>
    mjSENS_CAMPROJECTION: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_CAMPROJECTION: 8>
    mjSENS_CLOCK: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_CLOCK: 40>
    mjSENS_FORCE: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FORCE: 4>
    mjSENS_FRAMEANGACC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEANGACC: 33>
    mjSENS_FRAMEANGVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEANGVEL: 31>
    mjSENS_FRAMELINACC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMELINACC: 32>
    mjSENS_FRAMELINVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMELINVEL: 30>
    mjSENS_FRAMEPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEPOS: 25>
    mjSENS_FRAMEQUAT: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEQUAT: 26>
    mjSENS_FRAMEXAXIS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEXAXIS: 27>
    mjSENS_FRAMEYAXIS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEYAXIS: 28>
    mjSENS_FRAMEZAXIS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_FRAMEZAXIS: 29>
    mjSENS_GEOMDIST: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_GEOMDIST: 37>
    mjSENS_GEOMFROMTO: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_GEOMFROMTO: 39>
    mjSENS_GEOMNORMAL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_GEOMNORMAL: 38>
    mjSENS_GYRO: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_GYRO: 3>
    mjSENS_JOINTACTFRC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTACTFRC: 16>
    mjSENS_JOINTLIMITFRC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTLIMITFRC: 21>
    mjSENS_JOINTLIMITPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTLIMITPOS: 19>
    mjSENS_JOINTLIMITVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTLIMITVEL: 20>
    mjSENS_JOINTPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTPOS: 9>
    mjSENS_JOINTVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_JOINTVEL: 10>
    mjSENS_MAGNETOMETER: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_MAGNETOMETER: 6>
    mjSENS_PLUGIN: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_PLUGIN: 41>
    mjSENS_RANGEFINDER: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_RANGEFINDER: 7>
    mjSENS_SUBTREEANGMOM: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_SUBTREEANGMOM: 36>
    mjSENS_SUBTREECOM: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_SUBTREECOM: 34>
    mjSENS_SUBTREELINVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_SUBTREELINVEL: 35>
    mjSENS_TENDONLIMITFRC: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TENDONLIMITFRC: 24>
    mjSENS_TENDONLIMITPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TENDONLIMITPOS: 22>
    mjSENS_TENDONLIMITVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TENDONLIMITVEL: 23>
    mjSENS_TENDONPOS: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TENDONPOS: 11>
    mjSENS_TENDONVEL: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TENDONVEL: 12>
    mjSENS_TORQUE: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TORQUE: 5>
    mjSENS_TOUCH: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_TOUCH: 0>
    mjSENS_USER: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_USER: 42>
    mjSENS_VELOCIMETER: typing.ClassVar[mjtSensor]  # value = <mjtSensor.mjSENS_VELOCIMETER: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtSolver:
    """
    Members:
    
      mjSOL_PGS
    
      mjSOL_CG
    
      mjSOL_NEWTON
    """
    __members__: typing.ClassVar[dict[str, mjtSolver]]  # value = {'mjSOL_PGS': <mjtSolver.mjSOL_PGS: 0>, 'mjSOL_CG': <mjtSolver.mjSOL_CG: 1>, 'mjSOL_NEWTON': <mjtSolver.mjSOL_NEWTON: 2>}
    mjSOL_CG: typing.ClassVar[mjtSolver]  # value = <mjtSolver.mjSOL_CG: 1>
    mjSOL_NEWTON: typing.ClassVar[mjtSolver]  # value = <mjtSolver.mjSOL_NEWTON: 2>
    mjSOL_PGS: typing.ClassVar[mjtSolver]  # value = <mjtSolver.mjSOL_PGS: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtStage:
    """
    Members:
    
      mjSTAGE_NONE
    
      mjSTAGE_POS
    
      mjSTAGE_VEL
    
      mjSTAGE_ACC
    """
    __members__: typing.ClassVar[dict[str, mjtStage]]  # value = {'mjSTAGE_NONE': <mjtStage.mjSTAGE_NONE: 0>, 'mjSTAGE_POS': <mjtStage.mjSTAGE_POS: 1>, 'mjSTAGE_VEL': <mjtStage.mjSTAGE_VEL: 2>, 'mjSTAGE_ACC': <mjtStage.mjSTAGE_ACC: 3>}
    mjSTAGE_ACC: typing.ClassVar[mjtStage]  # value = <mjtStage.mjSTAGE_ACC: 3>
    mjSTAGE_NONE: typing.ClassVar[mjtStage]  # value = <mjtStage.mjSTAGE_NONE: 0>
    mjSTAGE_POS: typing.ClassVar[mjtStage]  # value = <mjtStage.mjSTAGE_POS: 1>
    mjSTAGE_VEL: typing.ClassVar[mjtStage]  # value = <mjtStage.mjSTAGE_VEL: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtState:
    """
    Members:
    
      mjSTATE_TIME
    
      mjSTATE_QPOS
    
      mjSTATE_QVEL
    
      mjSTATE_ACT
    
      mjSTATE_WARMSTART
    
      mjSTATE_CTRL
    
      mjSTATE_QFRC_APPLIED
    
      mjSTATE_XFRC_APPLIED
    
      mjSTATE_EQ_ACTIVE
    
      mjSTATE_MOCAP_POS
    
      mjSTATE_MOCAP_QUAT
    
      mjSTATE_USERDATA
    
      mjSTATE_PLUGIN
    
      mjNSTATE
    
      mjSTATE_PHYSICS
    
      mjSTATE_FULLPHYSICS
    
      mjSTATE_USER
    
      mjSTATE_INTEGRATION
    """
    __members__: typing.ClassVar[dict[str, mjtState]]  # value = {'mjSTATE_TIME': <mjtState.mjSTATE_TIME: 1>, 'mjSTATE_QPOS': <mjtState.mjSTATE_QPOS: 2>, 'mjSTATE_QVEL': <mjtState.mjSTATE_QVEL: 4>, 'mjSTATE_ACT': <mjtState.mjSTATE_ACT: 8>, 'mjSTATE_WARMSTART': <mjtState.mjSTATE_WARMSTART: 16>, 'mjSTATE_CTRL': <mjtState.mjSTATE_CTRL: 32>, 'mjSTATE_QFRC_APPLIED': <mjtState.mjSTATE_QFRC_APPLIED: 64>, 'mjSTATE_XFRC_APPLIED': <mjtState.mjSTATE_XFRC_APPLIED: 128>, 'mjSTATE_EQ_ACTIVE': <mjtState.mjSTATE_EQ_ACTIVE: 256>, 'mjSTATE_MOCAP_POS': <mjtState.mjSTATE_MOCAP_POS: 512>, 'mjSTATE_MOCAP_QUAT': <mjtState.mjSTATE_MOCAP_QUAT: 1024>, 'mjSTATE_USERDATA': <mjtState.mjSTATE_USERDATA: 2048>, 'mjSTATE_PLUGIN': <mjtState.mjSTATE_PLUGIN: 4096>, 'mjNSTATE': <mjtState.mjNSTATE: 13>, 'mjSTATE_PHYSICS': <mjtState.mjSTATE_PHYSICS: 14>, 'mjSTATE_FULLPHYSICS': <mjtState.mjSTATE_FULLPHYSICS: 4111>, 'mjSTATE_USER': <mjtState.mjSTATE_USER: 4064>, 'mjSTATE_INTEGRATION': <mjtState.mjSTATE_INTEGRATION: 8191>}
    mjNSTATE: typing.ClassVar[mjtState]  # value = <mjtState.mjNSTATE: 13>
    mjSTATE_ACT: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_ACT: 8>
    mjSTATE_CTRL: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_CTRL: 32>
    mjSTATE_EQ_ACTIVE: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_EQ_ACTIVE: 256>
    mjSTATE_FULLPHYSICS: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_FULLPHYSICS: 4111>
    mjSTATE_INTEGRATION: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_INTEGRATION: 8191>
    mjSTATE_MOCAP_POS: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_MOCAP_POS: 512>
    mjSTATE_MOCAP_QUAT: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_MOCAP_QUAT: 1024>
    mjSTATE_PHYSICS: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_PHYSICS: 14>
    mjSTATE_PLUGIN: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_PLUGIN: 4096>
    mjSTATE_QFRC_APPLIED: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_QFRC_APPLIED: 64>
    mjSTATE_QPOS: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_QPOS: 2>
    mjSTATE_QVEL: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_QVEL: 4>
    mjSTATE_TIME: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_TIME: 1>
    mjSTATE_USER: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_USER: 4064>
    mjSTATE_USERDATA: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_USERDATA: 2048>
    mjSTATE_WARMSTART: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_WARMSTART: 16>
    mjSTATE_XFRC_APPLIED: typing.ClassVar[mjtState]  # value = <mjtState.mjSTATE_XFRC_APPLIED: 128>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtStereo:
    """
    Members:
    
      mjSTEREO_NONE
    
      mjSTEREO_QUADBUFFERED
    
      mjSTEREO_SIDEBYSIDE
    """
    __members__: typing.ClassVar[dict[str, mjtStereo]]  # value = {'mjSTEREO_NONE': <mjtStereo.mjSTEREO_NONE: 0>, 'mjSTEREO_QUADBUFFERED': <mjtStereo.mjSTEREO_QUADBUFFERED: 1>, 'mjSTEREO_SIDEBYSIDE': <mjtStereo.mjSTEREO_SIDEBYSIDE: 2>}
    mjSTEREO_NONE: typing.ClassVar[mjtStereo]  # value = <mjtStereo.mjSTEREO_NONE: 0>
    mjSTEREO_QUADBUFFERED: typing.ClassVar[mjtStereo]  # value = <mjtStereo.mjSTEREO_QUADBUFFERED: 1>
    mjSTEREO_SIDEBYSIDE: typing.ClassVar[mjtStereo]  # value = <mjtStereo.mjSTEREO_SIDEBYSIDE: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtTaskStatus:
    """
    Members:
    
      mjTASK_NEW
    
      mjTASK_QUEUED
    
      mjTASK_COMPLETED
    """
    __members__: typing.ClassVar[dict[str, mjtTaskStatus]]  # value = {'mjTASK_NEW': <mjtTaskStatus.mjTASK_NEW: 0>, 'mjTASK_QUEUED': <mjtTaskStatus.mjTASK_QUEUED: 1>, 'mjTASK_COMPLETED': <mjtTaskStatus.mjTASK_COMPLETED: 2>}
    mjTASK_COMPLETED: typing.ClassVar[mjtTaskStatus]  # value = <mjtTaskStatus.mjTASK_COMPLETED: 2>
    mjTASK_NEW: typing.ClassVar[mjtTaskStatus]  # value = <mjtTaskStatus.mjTASK_NEW: 0>
    mjTASK_QUEUED: typing.ClassVar[mjtTaskStatus]  # value = <mjtTaskStatus.mjTASK_QUEUED: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtTexture:
    """
    Members:
    
      mjTEXTURE_2D
    
      mjTEXTURE_CUBE
    
      mjTEXTURE_SKYBOX
    """
    __members__: typing.ClassVar[dict[str, mjtTexture]]  # value = {'mjTEXTURE_2D': <mjtTexture.mjTEXTURE_2D: 0>, 'mjTEXTURE_CUBE': <mjtTexture.mjTEXTURE_CUBE: 1>, 'mjTEXTURE_SKYBOX': <mjtTexture.mjTEXTURE_SKYBOX: 2>}
    mjTEXTURE_2D: typing.ClassVar[mjtTexture]  # value = <mjtTexture.mjTEXTURE_2D: 0>
    mjTEXTURE_CUBE: typing.ClassVar[mjtTexture]  # value = <mjtTexture.mjTEXTURE_CUBE: 1>
    mjTEXTURE_SKYBOX: typing.ClassVar[mjtTexture]  # value = <mjtTexture.mjTEXTURE_SKYBOX: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtTextureRole:
    """
    Members:
    
      mjTEXROLE_USER
    
      mjTEXROLE_RGB
    
      mjTEXROLE_OCCLUSION
    
      mjTEXROLE_ROUGHNESS
    
      mjTEXROLE_METALLIC
    
      mjTEXROLE_NORMAL
    
      mjTEXROLE_OPACITY
    
      mjTEXROLE_EMISSIVE
    
      mjTEXROLE_RGBA
    
      mjTEXROLE_ORM
    
      mjNTEXROLE
    """
    __members__: typing.ClassVar[dict[str, mjtTextureRole]]  # value = {'mjTEXROLE_USER': <mjtTextureRole.mjTEXROLE_USER: 0>, 'mjTEXROLE_RGB': <mjtTextureRole.mjTEXROLE_RGB: 1>, 'mjTEXROLE_OCCLUSION': <mjtTextureRole.mjTEXROLE_OCCLUSION: 2>, 'mjTEXROLE_ROUGHNESS': <mjtTextureRole.mjTEXROLE_ROUGHNESS: 3>, 'mjTEXROLE_METALLIC': <mjtTextureRole.mjTEXROLE_METALLIC: 4>, 'mjTEXROLE_NORMAL': <mjtTextureRole.mjTEXROLE_NORMAL: 5>, 'mjTEXROLE_OPACITY': <mjtTextureRole.mjTEXROLE_OPACITY: 6>, 'mjTEXROLE_EMISSIVE': <mjtTextureRole.mjTEXROLE_EMISSIVE: 7>, 'mjTEXROLE_RGBA': <mjtTextureRole.mjTEXROLE_RGBA: 8>, 'mjTEXROLE_ORM': <mjtTextureRole.mjTEXROLE_ORM: 9>, 'mjNTEXROLE': <mjtTextureRole.mjNTEXROLE: 10>}
    mjNTEXROLE: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjNTEXROLE: 10>
    mjTEXROLE_EMISSIVE: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_EMISSIVE: 7>
    mjTEXROLE_METALLIC: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_METALLIC: 4>
    mjTEXROLE_NORMAL: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_NORMAL: 5>
    mjTEXROLE_OCCLUSION: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_OCCLUSION: 2>
    mjTEXROLE_OPACITY: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_OPACITY: 6>
    mjTEXROLE_ORM: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_ORM: 9>
    mjTEXROLE_RGB: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_RGB: 1>
    mjTEXROLE_RGBA: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_RGBA: 8>
    mjTEXROLE_ROUGHNESS: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_ROUGHNESS: 3>
    mjTEXROLE_USER: typing.ClassVar[mjtTextureRole]  # value = <mjtTextureRole.mjTEXROLE_USER: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtTimer:
    """
    Members:
    
      mjTIMER_STEP
    
      mjTIMER_FORWARD
    
      mjTIMER_INVERSE
    
      mjTIMER_POSITION
    
      mjTIMER_VELOCITY
    
      mjTIMER_ACTUATION
    
      mjTIMER_CONSTRAINT
    
      mjTIMER_ADVANCE
    
      mjTIMER_POS_KINEMATICS
    
      mjTIMER_POS_INERTIA
    
      mjTIMER_POS_COLLISION
    
      mjTIMER_POS_MAKE
    
      mjTIMER_POS_PROJECT
    
      mjTIMER_COL_BROAD
    
      mjTIMER_COL_NARROW
    
      mjNTIMER
    """
    __members__: typing.ClassVar[dict[str, mjtTimer]]  # value = {'mjTIMER_STEP': <mjtTimer.mjTIMER_STEP: 0>, 'mjTIMER_FORWARD': <mjtTimer.mjTIMER_FORWARD: 1>, 'mjTIMER_INVERSE': <mjtTimer.mjTIMER_INVERSE: 2>, 'mjTIMER_POSITION': <mjtTimer.mjTIMER_POSITION: 3>, 'mjTIMER_VELOCITY': <mjtTimer.mjTIMER_VELOCITY: 4>, 'mjTIMER_ACTUATION': <mjtTimer.mjTIMER_ACTUATION: 5>, 'mjTIMER_CONSTRAINT': <mjtTimer.mjTIMER_CONSTRAINT: 6>, 'mjTIMER_ADVANCE': <mjtTimer.mjTIMER_ADVANCE: 7>, 'mjTIMER_POS_KINEMATICS': <mjtTimer.mjTIMER_POS_KINEMATICS: 8>, 'mjTIMER_POS_INERTIA': <mjtTimer.mjTIMER_POS_INERTIA: 9>, 'mjTIMER_POS_COLLISION': <mjtTimer.mjTIMER_POS_COLLISION: 10>, 'mjTIMER_POS_MAKE': <mjtTimer.mjTIMER_POS_MAKE: 11>, 'mjTIMER_POS_PROJECT': <mjtTimer.mjTIMER_POS_PROJECT: 12>, 'mjTIMER_COL_BROAD': <mjtTimer.mjTIMER_COL_BROAD: 13>, 'mjTIMER_COL_NARROW': <mjtTimer.mjTIMER_COL_NARROW: 14>, 'mjNTIMER': <mjtTimer.mjNTIMER: 15>}
    mjNTIMER: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjNTIMER: 15>
    mjTIMER_ACTUATION: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_ACTUATION: 5>
    mjTIMER_ADVANCE: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_ADVANCE: 7>
    mjTIMER_COL_BROAD: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_COL_BROAD: 13>
    mjTIMER_COL_NARROW: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_COL_NARROW: 14>
    mjTIMER_CONSTRAINT: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_CONSTRAINT: 6>
    mjTIMER_FORWARD: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_FORWARD: 1>
    mjTIMER_INVERSE: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_INVERSE: 2>
    mjTIMER_POSITION: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POSITION: 3>
    mjTIMER_POS_COLLISION: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POS_COLLISION: 10>
    mjTIMER_POS_INERTIA: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POS_INERTIA: 9>
    mjTIMER_POS_KINEMATICS: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POS_KINEMATICS: 8>
    mjTIMER_POS_MAKE: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POS_MAKE: 11>
    mjTIMER_POS_PROJECT: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_POS_PROJECT: 12>
    mjTIMER_STEP: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_STEP: 0>
    mjTIMER_VELOCITY: typing.ClassVar[mjtTimer]  # value = <mjtTimer.mjTIMER_VELOCITY: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtTrn:
    """
    Members:
    
      mjTRN_JOINT
    
      mjTRN_JOINTINPARENT
    
      mjTRN_SLIDERCRANK
    
      mjTRN_TENDON
    
      mjTRN_SITE
    
      mjTRN_BODY
    
      mjTRN_UNDEFINED
    """
    __members__: typing.ClassVar[dict[str, mjtTrn]]  # value = {'mjTRN_JOINT': <mjtTrn.mjTRN_JOINT: 0>, 'mjTRN_JOINTINPARENT': <mjtTrn.mjTRN_JOINTINPARENT: 1>, 'mjTRN_SLIDERCRANK': <mjtTrn.mjTRN_SLIDERCRANK: 2>, 'mjTRN_TENDON': <mjtTrn.mjTRN_TENDON: 3>, 'mjTRN_SITE': <mjtTrn.mjTRN_SITE: 4>, 'mjTRN_BODY': <mjtTrn.mjTRN_BODY: 5>, 'mjTRN_UNDEFINED': <mjtTrn.mjTRN_UNDEFINED: 1000>}
    mjTRN_BODY: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_BODY: 5>
    mjTRN_JOINT: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_JOINT: 0>
    mjTRN_JOINTINPARENT: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_JOINTINPARENT: 1>
    mjTRN_SITE: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_SITE: 4>
    mjTRN_SLIDERCRANK: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_SLIDERCRANK: 2>
    mjTRN_TENDON: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_TENDON: 3>
    mjTRN_UNDEFINED: typing.ClassVar[mjtTrn]  # value = <mjtTrn.mjTRN_UNDEFINED: 1000>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtVisFlag:
    """
    Members:
    
      mjVIS_CONVEXHULL
    
      mjVIS_TEXTURE
    
      mjVIS_JOINT
    
      mjVIS_CAMERA
    
      mjVIS_ACTUATOR
    
      mjVIS_ACTIVATION
    
      mjVIS_LIGHT
    
      mjVIS_TENDON
    
      mjVIS_RANGEFINDER
    
      mjVIS_CONSTRAINT
    
      mjVIS_INERTIA
    
      mjVIS_SCLINERTIA
    
      mjVIS_PERTFORCE
    
      mjVIS_PERTOBJ
    
      mjVIS_CONTACTPOINT
    
      mjVIS_ISLAND
    
      mjVIS_CONTACTFORCE
    
      mjVIS_CONTACTSPLIT
    
      mjVIS_TRANSPARENT
    
      mjVIS_AUTOCONNECT
    
      mjVIS_COM
    
      mjVIS_SELECT
    
      mjVIS_STATIC
    
      mjVIS_SKIN
    
      mjVIS_FLEXVERT
    
      mjVIS_FLEXEDGE
    
      mjVIS_FLEXFACE
    
      mjVIS_FLEXSKIN
    
      mjVIS_BODYBVH
    
      mjVIS_FLEXBVH
    
      mjVIS_MESHBVH
    
      mjVIS_SDFITER
    
      mjNVISFLAG
    """
    __members__: typing.ClassVar[dict[str, mjtVisFlag]]  # value = {'mjVIS_CONVEXHULL': <mjtVisFlag.mjVIS_CONVEXHULL: 0>, 'mjVIS_TEXTURE': <mjtVisFlag.mjVIS_TEXTURE: 1>, 'mjVIS_JOINT': <mjtVisFlag.mjVIS_JOINT: 2>, 'mjVIS_CAMERA': <mjtVisFlag.mjVIS_CAMERA: 3>, 'mjVIS_ACTUATOR': <mjtVisFlag.mjVIS_ACTUATOR: 4>, 'mjVIS_ACTIVATION': <mjtVisFlag.mjVIS_ACTIVATION: 5>, 'mjVIS_LIGHT': <mjtVisFlag.mjVIS_LIGHT: 6>, 'mjVIS_TENDON': <mjtVisFlag.mjVIS_TENDON: 7>, 'mjVIS_RANGEFINDER': <mjtVisFlag.mjVIS_RANGEFINDER: 8>, 'mjVIS_CONSTRAINT': <mjtVisFlag.mjVIS_CONSTRAINT: 9>, 'mjVIS_INERTIA': <mjtVisFlag.mjVIS_INERTIA: 10>, 'mjVIS_SCLINERTIA': <mjtVisFlag.mjVIS_SCLINERTIA: 11>, 'mjVIS_PERTFORCE': <mjtVisFlag.mjVIS_PERTFORCE: 12>, 'mjVIS_PERTOBJ': <mjtVisFlag.mjVIS_PERTOBJ: 13>, 'mjVIS_CONTACTPOINT': <mjtVisFlag.mjVIS_CONTACTPOINT: 14>, 'mjVIS_ISLAND': <mjtVisFlag.mjVIS_ISLAND: 15>, 'mjVIS_CONTACTFORCE': <mjtVisFlag.mjVIS_CONTACTFORCE: 16>, 'mjVIS_CONTACTSPLIT': <mjtVisFlag.mjVIS_CONTACTSPLIT: 17>, 'mjVIS_TRANSPARENT': <mjtVisFlag.mjVIS_TRANSPARENT: 18>, 'mjVIS_AUTOCONNECT': <mjtVisFlag.mjVIS_AUTOCONNECT: 19>, 'mjVIS_COM': <mjtVisFlag.mjVIS_COM: 20>, 'mjVIS_SELECT': <mjtVisFlag.mjVIS_SELECT: 21>, 'mjVIS_STATIC': <mjtVisFlag.mjVIS_STATIC: 22>, 'mjVIS_SKIN': <mjtVisFlag.mjVIS_SKIN: 23>, 'mjVIS_FLEXVERT': <mjtVisFlag.mjVIS_FLEXVERT: 24>, 'mjVIS_FLEXEDGE': <mjtVisFlag.mjVIS_FLEXEDGE: 25>, 'mjVIS_FLEXFACE': <mjtVisFlag.mjVIS_FLEXFACE: 26>, 'mjVIS_FLEXSKIN': <mjtVisFlag.mjVIS_FLEXSKIN: 27>, 'mjVIS_BODYBVH': <mjtVisFlag.mjVIS_BODYBVH: 28>, 'mjVIS_FLEXBVH': <mjtVisFlag.mjVIS_FLEXBVH: 29>, 'mjVIS_MESHBVH': <mjtVisFlag.mjVIS_MESHBVH: 30>, 'mjVIS_SDFITER': <mjtVisFlag.mjVIS_SDFITER: 31>, 'mjNVISFLAG': <mjtVisFlag.mjNVISFLAG: 32>}
    mjNVISFLAG: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjNVISFLAG: 32>
    mjVIS_ACTIVATION: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_ACTIVATION: 5>
    mjVIS_ACTUATOR: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_ACTUATOR: 4>
    mjVIS_AUTOCONNECT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_AUTOCONNECT: 19>
    mjVIS_BODYBVH: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_BODYBVH: 28>
    mjVIS_CAMERA: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CAMERA: 3>
    mjVIS_COM: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_COM: 20>
    mjVIS_CONSTRAINT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CONSTRAINT: 9>
    mjVIS_CONTACTFORCE: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CONTACTFORCE: 16>
    mjVIS_CONTACTPOINT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CONTACTPOINT: 14>
    mjVIS_CONTACTSPLIT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CONTACTSPLIT: 17>
    mjVIS_CONVEXHULL: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_CONVEXHULL: 0>
    mjVIS_FLEXBVH: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_FLEXBVH: 29>
    mjVIS_FLEXEDGE: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_FLEXEDGE: 25>
    mjVIS_FLEXFACE: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_FLEXFACE: 26>
    mjVIS_FLEXSKIN: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_FLEXSKIN: 27>
    mjVIS_FLEXVERT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_FLEXVERT: 24>
    mjVIS_INERTIA: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_INERTIA: 10>
    mjVIS_ISLAND: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_ISLAND: 15>
    mjVIS_JOINT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_JOINT: 2>
    mjVIS_LIGHT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_LIGHT: 6>
    mjVIS_MESHBVH: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_MESHBVH: 30>
    mjVIS_PERTFORCE: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_PERTFORCE: 12>
    mjVIS_PERTOBJ: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_PERTOBJ: 13>
    mjVIS_RANGEFINDER: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_RANGEFINDER: 8>
    mjVIS_SCLINERTIA: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_SCLINERTIA: 11>
    mjVIS_SDFITER: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_SDFITER: 31>
    mjVIS_SELECT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_SELECT: 21>
    mjVIS_SKIN: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_SKIN: 23>
    mjVIS_STATIC: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_STATIC: 22>
    mjVIS_TENDON: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_TENDON: 7>
    mjVIS_TEXTURE: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_TEXTURE: 1>
    mjVIS_TRANSPARENT: typing.ClassVar[mjtVisFlag]  # value = <mjtVisFlag.mjVIS_TRANSPARENT: 18>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtWarning:
    """
    Members:
    
      mjWARN_INERTIA
    
      mjWARN_CONTACTFULL
    
      mjWARN_CNSTRFULL
    
      mjWARN_VGEOMFULL
    
      mjWARN_BADQPOS
    
      mjWARN_BADQVEL
    
      mjWARN_BADQACC
    
      mjWARN_BADCTRL
    
      mjNWARNING
    """
    __members__: typing.ClassVar[dict[str, mjtWarning]]  # value = {'mjWARN_INERTIA': <mjtWarning.mjWARN_INERTIA: 0>, 'mjWARN_CONTACTFULL': <mjtWarning.mjWARN_CONTACTFULL: 1>, 'mjWARN_CNSTRFULL': <mjtWarning.mjWARN_CNSTRFULL: 2>, 'mjWARN_VGEOMFULL': <mjtWarning.mjWARN_VGEOMFULL: 3>, 'mjWARN_BADQPOS': <mjtWarning.mjWARN_BADQPOS: 4>, 'mjWARN_BADQVEL': <mjtWarning.mjWARN_BADQVEL: 5>, 'mjWARN_BADQACC': <mjtWarning.mjWARN_BADQACC: 6>, 'mjWARN_BADCTRL': <mjtWarning.mjWARN_BADCTRL: 7>, 'mjNWARNING': <mjtWarning.mjNWARNING: 8>}
    mjNWARNING: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjNWARNING: 8>
    mjWARN_BADCTRL: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_BADCTRL: 7>
    mjWARN_BADQACC: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_BADQACC: 6>
    mjWARN_BADQPOS: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_BADQPOS: 4>
    mjWARN_BADQVEL: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_BADQVEL: 5>
    mjWARN_CNSTRFULL: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_CNSTRFULL: 2>
    mjWARN_CONTACTFULL: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_CONTACTFULL: 1>
    mjWARN_INERTIA: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_INERTIA: 0>
    mjWARN_VGEOMFULL: typing.ClassVar[mjtWarning]  # value = <mjtWarning.mjWARN_VGEOMFULL: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class mjtWrap:
    """
    Members:
    
      mjWRAP_NONE
    
      mjWRAP_JOINT
    
      mjWRAP_PULLEY
    
      mjWRAP_SITE
    
      mjWRAP_SPHERE
    
      mjWRAP_CYLINDER
    """
    __members__: typing.ClassVar[dict[str, mjtWrap]]  # value = {'mjWRAP_NONE': <mjtWrap.mjWRAP_NONE: 0>, 'mjWRAP_JOINT': <mjtWrap.mjWRAP_JOINT: 1>, 'mjWRAP_PULLEY': <mjtWrap.mjWRAP_PULLEY: 2>, 'mjWRAP_SITE': <mjtWrap.mjWRAP_SITE: 3>, 'mjWRAP_SPHERE': <mjtWrap.mjWRAP_SPHERE: 4>, 'mjWRAP_CYLINDER': <mjtWrap.mjWRAP_CYLINDER: 5>}
    mjWRAP_CYLINDER: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_CYLINDER: 5>
    mjWRAP_JOINT: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_JOINT: 1>
    mjWRAP_NONE: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_NONE: 0>
    mjWRAP_PULLEY: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_PULLEY: 2>
    mjWRAP_SITE: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_SITE: 3>
    mjWRAP_SPHERE: typing.ClassVar[mjtWrap]  # value = <mjtWrap.mjWRAP_SPHERE: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> float:
        ...
    def __and__(self, arg0: int) -> int:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    @typing.overload
    def __floordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __floordiv__(self, arg0: float) -> float:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    @typing.overload
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __lshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> float:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __neg__(self) -> int:
        ...
    def __or__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> float:
        ...
    def __rand__(self, arg0: int) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rfloordiv__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmod__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmod__(self, arg0: float) -> float:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> float:
        ...
    def __ror__(self, arg0: int) -> int:
        ...
    def __rshift__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> float:
        ...
    def __rtruediv__(self, arg0: float) -> float:
        ...
    def __rxor__(self, arg0: int) -> int:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> float:
        ...
    def __truediv__(self, arg0: float) -> float:
        ...
    def __xor__(self, arg0: int) -> int:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
