use std::{f32::consts::PI, time::SystemTime};

use linear_algebra::{point, Point2};
use nalgebra::{
    linalg::SymmetricEigen, DMatrix, DVector, Matrix3, Matrix3xX, Matrix5, SMatrix, Schur, Vector3,
};

#[derive(Debug, Copy, Clone)]
pub struct Ellipse<Frame> {
    pub center: Point2<Frame>,
    pub major: f32,
    pub minor: f32,
    pub angle: f32,
    pub residuel: f32,
}
/// Generated by Google Gemini based on the listed publications and improved.
///
/// Implements the ElliFit algorithm for fitting an ellipse to a set of 2D points.
///
/// This implementation is based on the described methods in
/// * "ElliFit: An unconstrained, non-iterative, least squares based geometric Ellipse Fitting method"
/// * "Center circle detection on the NAO robotic platform for the RoboCup Standard Platform League"
///
/// # Arguments
///
/// * `points`: A vector of 2D points representing the data.
///
///
/// # Notes
/// * Equation numbers and matrix names are marked according to the ElliFit paper
/// * This implementation assumes that the input data contains at least 5 points.
///

pub fn ellifit<Frame>(points: &[Point2<Frame, f32>]) -> Result<Ellipse<Frame>, String> {
    if points.len() < 5 {
        return Err("ElliFit requires at least 5 points.".to_owned());
    }

    // Calculate the centroid of the points
    let centroid = points.iter().fold(point![0.0, 0.0], |acc, &p| {
        (acc.coords() + p.cast().coords()).as_point()
    }) / points.len() as f64;

    // Translate the points to the centroid
    let translated_points: Vec<_> = points.iter().map(|&p| p.cast() - centroid).collect();
    // println!("centroid: {}", centroid.inner);

    // works but biased
    let a_mat = DMatrix::from_row_iterator(
        translated_points.len(),
        5,
        translated_points
            .iter()
            .map(|p| {
                // x^2, 2xy, -x, -y, -1
                [-p.x().powi(2), -p.x() * p.y(), p.x(), p.y(), -1.0f64]
            })
            .flatten(),
    );

    let b_mat = DVector::from_iterator(
        translated_points.len(),
        translated_points.iter().map(|p| p.y().powi(2)),
    );

    // let a_tr_a_inv = (&a_mat)
    //     .tr_mul(&a_mat)
    //     .try_inverse()
    //     .expect("This matrix should be invertible");
    // let phi = ( (a.transpose(). * a).inverse()) * a.transpose() * b;
    // let phi = a_tr_a_inv * a_mat.tr_mul(&b_mat);
    // Instead of inv(A.T * A) * A.T * b, we can use the QR decomposition (See Nicholas' PA)
    let qr = a_mat.clone().qr();
    let phi = qr
        .r()
        .solve_upper_triangular(&qr.q().tr_mul(&b_mat))
        .expect("There should be a solution");

    let residuel = ((a_mat * &phi) - &b_mat).norm() / &b_mat.norm();

    let p1 = phi[0];
    let p2 = phi[1];
    let p3 = phi[2];
    let p4 = phi[3];
    let p5 = phi[4];

    let p1_4 = 4.0 * p1;
    let one_minus_p1 = 1.0 - p1;
    let one_plus_p1 = 1.0 + p1;
    let p2_sq = p2.powi(2);
    let p2sq_minus_p1_4 = p2_sq - p1_4;
    let x = (p2 * p4 - 2.0 * p3) / p2sq_minus_p1_4;
    let y = (p2 * p3 - 2.0 * p1 * p4) / p2sq_minus_p1_4;

    let temp1 = (one_minus_p1.powi(2) + (4.0 * p2_sq)).sqrt();
    let numerator = p2 * p3 * p4 - p4.powi(2) * p1 - p3.powi(2) - p5 * p2sq_minus_p1_4;
    let major = 2.0 * (numerator / (p2sq_minus_p1_4 * (one_plus_p1 - temp1))).sqrt();
    let minor = 2.0 * (numerator / (p2sq_minus_p1_4 * (one_plus_p1 + temp1))).sqrt();
    // let x = (p3 - (p4 * p2)) / (p1 - (p2 * p2));
    // let y = ((p1 * p4) - (p3 * p2)) / (p1 - (p2 * p2));

    // let temp1 = (one_minus_p1.powi(2) + (4.0 * (p2.powi(2)))).sqrt();
    // let temp2 = p5 + (y.powi(2)) + (x.powi(2) * p1) + (2.0 * p2);
    // let temp3 = 1.0 + p1;

    let angle = -0.5 * (-p2).atan2(one_minus_p1);

    // let minor = 2.0 * (temp2 / (temp3 + temp1)).abs().sqrt();
    // let major = 2.0 * (temp2 / (temp3 - temp1)).abs().sqrt();
    // ell.minorRadius = sqrt(fabs((2 * temp2) / (temp3 + temp1)));
    // ell.majorRadius = sqrt(fabs((2 * temp2) / (temp3 - temp1)));

    let center = (point![x, y].coords() + centroid.cast().coords()).as_point();

    // Return the ellipse parameters
    Ok(Ellipse {
        center: center.cast(),
        major: major as f32,
        minor: minor as f32,
        angle: angle as f32,
        residuel: residuel as f32,
    })
}

pub fn other_ellipse<Frame>(points: &[Point2<Frame>]) -> Result<Ellipse<Frame>, String> {
    // 1. Construct the design matrix D
    // TODO change to Matrix3xX style
    let d1 = Matrix3xX::from_iterator(
        points.len(),
        points
            .iter()
            .map(|p| [p.x().powi(2), p.x() * p.y(), p.y().powi(2)])
            .flatten(),
    )
    .transpose();

    let d2 = Matrix3xX::from_iterator(
        points.len(),
        points.iter().map(|p| [p.x(), p.y(), 1.0]).flatten(),
    )
    .transpose();

    let s1: Matrix3<f32> = d1.tr_mul(&d1);
    let s2: Matrix3<f32> = d1.tr_mul(&d2);
    let s3: Matrix3<f32> = d2.tr_mul(&d2);

    let mut D = Matrix3::<f32>::zeros();
    for &p in points {
        let x = p.x();
        let y = p.y();
        D[(0, 0)] += x * x;
        D[(0, 1)] += x * y;
        D[(0, 2)] += x;
        D[(1, 0)] = D[(0, 1)]; // Symmetric matrix
        D[(1, 1)] += y * y;
        D[(1, 2)] += y;
        D[(2, 0)] = D[(0, 2)];
        D[(2, 1)] = D[(1, 2)];
        D[(2, 2)] += 1.0;
    }

    // 2. Construct the constraint matrix C
    let c1 = Matrix3::new(0.0, 0.0, 2.0, 0.0, -1.0, 0.0, 2.0, 0.0, 0.0);

    let m: Matrix3<f32> =
        c1.try_inverse().unwrap() * (s1 - s2 * s3.try_inverse().unwrap() * s2.transpose());
    println!("m: {m}");
    // 3. Solve the generalized eigenvalue problem
    // let (eigenvalues, eigenvectors) = D.generalized_eigen(C, UPLO::Upper);
    let eig = SymmetricEigen::new(m);
    let eigenvalues = eig.eigenvalues;
    let eigenvectors = eig.eigenvectors;

    println!("D {D}");
    println!("eigenvalues: {eigenvalues}");
    println!("eigenvectors: {eigenvectors}");
    // 4. Find the eigenvector corresponding to the smallest eigenvalue
    let cond = 4.0 * eigenvectors.row(0).component_mul(&eigenvectors.row(2))
        - eigenvectors.row(1).component_mul(&eigenvectors.row(1));
    // cond = 4*np.multiply(eigvec[0, :], eigvec[2, :]) - np.power(eigvec[1, :], 2)
    // a1 = eigvec[:, np.nonzero(cond > 0)[0]]
    let min_eigenvalue_index = cond.iter().position(|&x| x < 0.0).unwrap();
    // let min_eigenvalue_index = eigenvalues
    //     .iter()
    //     .enumerate()
    //     .min_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
    //     .map(|(i, _)| i)
    //     .unwrap();
    let a1 = eigenvectors.column(min_eigenvalue_index);
    let a2 = (-s3).try_inverse().unwrap() * s2.transpose() * a1;
    println!("a1: {a1}, a2: {a2}");

    let e = m.eigenvalues().unwrap();
    let (q, t) = m.schur().unpack();

    let eigenvectors = e.map(|eigenvalue| {
        // Solve the system (schur - eigenvalue * I) * x = 0
        let eigenvector_system: Matrix3<f32> = (q - eigenvalue * Matrix3::identity());
        let v = eigenvector_system
            .solve_upper_triangular(&Vector3::zeros())
            .unwrap();
        q * v // Transform back to original basis
    });

    // let v =m.eigenvectors().unwrap();

    let (mut q, mut t) = m.schur().unpack();
    // let eigenvectors = s_eigenvectors.map(|v| q * v);

    // for i in 0..s_eigenvectors.ncols() {
    //     s_eigenvectors.column_mut(i).normalize_mut();
    // }

    println!("{eigenvectors}\n{e}");
    println!("e: {e}");
    println!("shur: {}\n{}", q, t);

    // D.solve_upper_triangular(b)
    // 5. Extract ellipse parameters
    let a = a1[0];
    let b = a1[1];
    let c = a1[2];
    let d = a2[0];
    let f = a2[1];
    let g = a2[2];

    // 6. Calculate ellipse parameters
    // let center = point![-0.5 * a / c, -0.5 * b / c];
    // let major = 1.0 / (2.0 * c * (1.0 - (a * a + b * b) / (4.0 * c)).sqrt());
    // let minor = 1.0 / (2.0 * c * (1.0 + (a * a + b * b) / (4.0 * c)).sqrt());
    // let angle = 0.5 * (-b / a).atan2(1.0);

    let x0 = (c * d - b * f) / (b.powi(2) - a * c);
    let y0 = (a * f - b * d) / (b.powi(2) - a * c);
    let center = point![x0, y0];

    let numerator =
        2.0 * (a * f.powi(2) + c * d.powi(2) + g * b.powi(2) - 2.0 * b * d * f - a * c * g);
    let denominator1 = (b.powi(2) - a * c) * (((a - c).powi(2) + 4.0 * b.powi(2)).sqrt() - (c + a));
    let denominator2 =
        (b.powi(2) - a * c) * (-((a - c).powi(2) + 4.0 * b.powi(2)).sqrt() - (c + a));
    let height = (numerator / denominator1).sqrt();
    let width = (numerator / denominator2).sqrt();

    let angle = if a == c {
        0.0
    } else {
        0.5 * (PI + (2.0 * b).atan2(a - c))
    };
    // if a == c {
    // if b == 0.0 && a > c:
    //     phi = 0.0
    // elif b == 0 and a < c:
    //     phi = np.pi/2
    // elif b != 0 and a > c:
    //     phi = 0.5 * np.arctan(2*b/(a-c))
    // elif b != 0 and a < c:
    //     phi = 0.5 * (np.pi + np.arctan(2*b/(a-c)))
    // elif a == c:
    //     logger.warning("Ellipse is a perfect circle, the answer is degenerate")
    //     phi = 0.0
    // else:
    //     raise RuntimeError("Unreachable")

    Ok(Ellipse {
        center,
        major: width,
        minor: height,
        angle,
        residuel: 0.0,
    })
}

#[cfg(test)]
mod tests {
    use std::f32::consts::FRAC_PI_4;

    use approx::assert_relative_eq;

    use super::*;

    #[derive(Debug)]
    struct DummyFrame;

    #[test]
    fn ellifit_test() {
        // let points = vec![
        //     point![1.0, 1.0],
        //     point![2.0, 2.0],
        //     point![3.0, 3.0],
        //     point![4.0, 4.0],
        //     point![5.0, 5.0],
        // ];

        // Define a set of points on an ellipse (centered at origin, rotated by 45 degrees)
        // let points: Vec<_> = vec![
        //     point![1.0, 1.0],
        //     point![-1.0, -1.0],
        //     point![1.4142, 0.0],  // sqrt(2)
        //     point![-1.4142, 0.0], // -sqrt(2)
        //     point![0.0, 1.4142],  // sqrt(2)
        //     point![0.0, -1.4142], // -sqrt(2)
        // ];

        // expected from python
        // center: 2.776, -0.010
        // width: 0.756
        // height: 0.837
        // phi: 0.658 <class 'numpy.float64'>

        let points: Vec<_> = vec![
            point![2.08537573, 0.48030994],
            point![3.10540613, 0.70164787],
            point![3.55411641, 0.13879143],
            point![2.02915708, -0.18899235],
            point![3.56519477, -0.06717689],
            point![3.57986527, 0.05212252],
            point![3.44286905, -0.46697632],
            point![2.01739203, -0.10048445],
            point![3.44157189, -0.47737772],
            point![2.14705919, 0.55092497],
        ];

        // sampled center: 2.780, 0.024
        // sampled width: 0.827
        // sampled height: 0.750
        // sampled phi: -0.678 <class 'numpy.float64'>
        let expected_center = point![2.780, 0.024];
        let expected_major_axis = 0.827;
        let expected_minor_axis = 0.750;
        let expected_rotation = -0.678;

        let fitted_result =
            ellifit::<DummyFrame>(&points).expect("Cannot fail as there is an ellipse!");
        let center = fitted_result.center;
        let major_axis = fitted_result.major;
        let minor_axis = fitted_result.minor;
        let rotation = fitted_result.angle;

        let b = other_ellipse(&points).unwrap();

        println!("Other ellipse: {b:?}");

        println!("center: {center:?},\nmajor_axis: {major_axis:?},\nminor_axis: {minor_axis:?},\nrotation: {rotation:?}");
        // let (center, a, b, phi) = ellifit::<DummyFrame>(&points);
        assert_relative_eq!(center, expected_center);
        assert_relative_eq!(major_axis, expected_major_axis);
        assert_relative_eq!(minor_axis, expected_minor_axis);
        assert_relative_eq!(rotation, expected_rotation);
    }
}
