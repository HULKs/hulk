use std::{thread::sleep, time::Duration, fs::File, io::Write, path::Path, ops::{Index, IndexMut}};

use color_eyre::eyre::Context;
use image::{RgbaImage, save_buffer, ColorType, RgbImage, Rgb};
use v4l2::{Camera, CameraParameters, ExposureMode, Fraction};

fn main() {
    println!("Hello, world!");
    let mut camera = Camera::open(
        "/dev/video-top",
        &CameraParameters {
            width: 640,
            height: 480,
            format: v4l2::Format::YUVU,
            time_per_frame: Fraction {
                numerator: 1,
                denominator: 30,
            },

            brightness: 0,
            contrast: 32,
            saturation: 64,
            hue: 0,
            white_balance_temperature_auto: true,
            gain: 16,
            hue_auto: true,
            white_balance_temperature: 2500,
            sharpness: 4,
            exposure_auto: ExposureMode::Auto,
            exposure_absolute: 512,
            focus_absolute: 0,
            focus_auto: false,

            automatic_exposure_control_weights: [1; 16],
            disable_digital_effects: false,
            flip_sensor: false,

            amount_of_buffers: 3,
        },
    )
    .wrap_err("Failed to open")
    .unwrap();
    camera.start().wrap_err("Failed to start").unwrap();
    let buffer = vec![0; 4 * 320 * 480];
    dbg!(buffer.as_ptr());
    camera.queue(buffer).wrap_err("Failed to queue").unwrap();
    camera
        .poll(Some(Duration::from_secs(1)))
        .wrap_err("Failed to poll")
        .unwrap();
    let buffer = camera.dequeue().wrap_err("Failed to dequeue").unwrap();
    dbg!(buffer.as_ptr());
    camera.stop().wrap_err("Failed to stop").unwrap();
    // save_buffer("image.png", &buffer, 320, 480, ColorType::Rgba8).unwrap();
    let image = Image422::from_slice(&buffer, 320, 480);
    image.save_to_ycbcr_444_file("image.png").unwrap();
    // let mut file = File::create("image").unwrap();
    // file.write(&buffer).unwrap();
}

#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[repr(C)]
pub struct YCbCr422 {
    pub y1: u8,
    pub cb: u8,
    pub y2: u8,
    pub cr: u8,
}

pub struct Image422 {
    pixels: Vec<YCbCr422>,
    width: usize,
    height: usize,
}

impl Image422 {
    pub fn zero(width: usize, height: usize) -> Self {
        Self {
            pixels: vec![Default::default(); width * height],
            width,
            height,
        }
    }

    #[allow(dead_code)]
    pub fn from_slice(data: &[u8], width: usize, height: usize) -> Self {
        Self {
            pixels: data
                .chunks(4)
                .map(|x| YCbCr422 {
                    y1: x[0],
                    cb: x[1],
                    y2: x[2],
                    cr: x[3],
                })
                .collect(),
            width,
            height,
        }
    }

    #[allow(dead_code)]
    pub fn pixels_as_mut_slice(&mut self) -> &mut [YCbCr422] {
        self.pixels.as_mut_slice()
    }

    pub fn save_to_ycbcr_444_file<P>(&self, file: P) -> color_eyre::Result<()>
    where
        P: AsRef<Path>,
    {
        let mut image = RgbImage::new(self.width() as u32 * 2, self.height() as u32);
        for y in 0..self.height() {
            for x in 0..self.width() {
                let pixel = self[(x, y)];
                image.put_pixel(x as u32 * 2, y as u32, Rgb([pixel.y1, pixel.cb, pixel.cr]));
                image.put_pixel(
                    x as u32 * 2 + 1,
                    y as u32,
                    Rgb([pixel.y2, pixel.cb, pixel.cr]),
                );
            }
        }
        Ok(image.save(file)?)
    }

    #[allow(dead_code)]
    pub fn width(&self) -> usize {
        self.width
    }

    #[allow(dead_code)]
    pub fn height(&self) -> usize {
        self.height
    }
}

impl Index<(usize, usize)> for Image422 {
    type Output = YCbCr422;

    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {
        &self.pixels[y * self.width + x]
    }
}

impl IndexMut<(usize, usize)> for Image422 {
    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {
        &mut self.pixels[y * self.width + x]
    }
}
